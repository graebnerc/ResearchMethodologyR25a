{
  "hash": "b6152b6df4cbaaf75bfc94506dc02adf",
  "result": {
    "markdown": "---\ntitle: Monte Carlo Simulations in R # Also check out line 43\nauthor: Claudius Gräbner-Radkowitsch\ndate: '2023-03-09'\ndocumentclass: scrartcl\nformat: \n  html:\n    theme: readable\n    highlight: tango\n    toc: true\n    toc_depth: 2\n    number_sections: true\n  pdf:\n    papersize: a4\n    toc: true\n    toc-depth: 2\n    number-sections: true\n    include-in-header: \n      text: |\n        \\usepackage{lmodern} \n        \\usepackage{graphicx}\n        \\usepackage{hyperref}\n        \\usepackage{url}                \n        \\usepackage{xcolor}\n        \\usepackage{booktabs}\n        \\usepackage{listings}\n        \\lstloadlanguages{R}\n        \n        \\definecolor{eufblue}{RGB}{0,57,91}\n        \\definecolor{eufgrey}{RGB}{111,111,111}\n        \\definecolor{euflightblue}{RGB}{105,170,205}\n        \n        \\hypersetup{\n        pdfauthor={Claudius Graebner-Radkowitsch}\n        colorlinks=true,\n        linkcolor=euflightblue,\n        urlcolor=euflightblue\n        }\n        \\usepackage[includehead,includefoot,top=2cm, bottom=1.5cm]{geometry}\n        \\usepackage[headsepline, footsepline]{scrlayer-scrpage}\n        \\pagestyle{scrheadings}\n        \\clearpairofpagestyles\n        \\ihead{Tutorial: Monte Carlo Simulations in R}\n        %\\chead{Kopfzeile Mitte}\n        \\ohead{\\pagemark} %\n        \\ifoot{}\n        \\cfoot{\\href{https://euf-datascience-spring24.netlify.app/}{\\normalfont\\color{eufblue}{Data Science Using R - Spring Semester 2024}}} % Fußzeile Mitte\n        \\ofoot{} \n        \\setkomafont{disposition}{\\color{eufblue}\\bfseries}\n---\n\n\n\n\n\nThis Tutorial explains the concept behind, and the implementation of \nMonte Carlo Simulations (MCS) in R. \nTo implement MCS, we will make use of one of the following two tools:\n`for`-loops or the `map`-functions from the package \n[purrr](https://purrr.tidyverse.org/).\nTherefore, the tutorial also contains a general methodological section on these\ntwo approaches that you might read independently of the particular applications\nto MCS below.\nIf you want to read a bit more about the topic of the tutorial, you may have a \nlook at [chapter 21](https://r4ds.had.co.nz/iteration.html) of \n[R for Data Science](https://r4ds.had.co.nz/index.html).\n\nThis tutorial assumes you are using a typical directory structure as described\nin the respective tutorial. \nDuring this tutorial we will use the following packages:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(here)\nlibrary(tidyr)\nlibrary(data.table)\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(scales)\nlibrary(purrr)\nlibrary(icaeDesign)\n```\n:::\n\n\n\n# The technical part: doing iteration tasks\n\nWhenever you are doing a certain task more than twice you should immediately\nbecome suspicious and ask yourself whether you can automate the task. We \nalready discussed the reasons behind this rationale and introduced one important\nway to achieve automation: the use of functions.\n\nHere we talk about a general approach that complements the use of functions \nwhen it comes to automation: the idea of *iteration*. \n\nHere we focus on two alternative ways of how to implement iterations in R:\nusing `for`-loops, or a `map`-function from the package\n[purrr](https://purrr.tidyverse.org/). \nThe latter option is clearer and more concise, the former is more \nflexible and intuitive. So, its generally good to know about both ways and\nthen choose the approach that you find more appealing for the case at hand.\n\nAs you will see below, the two iteration concepts and functions and complements,\nnot substitutes: often, especially in the context of MCS, you will write\nfunctions that you then combine with the iteration tools described below.\n\n## For loops\nThe idea of a for-loop is to 'loop over' an object, an do something for (or on)\nevery element in this object. \n\nIn general, every for-loop (should) consist of three parts:\n\n1. The output container\n2. The looping sequence\n3. The action body\n\nBelow we is an example loop that loops through a list with three vectors as \nelements elements, and computes the mean for each element of the list. Before\nwe inspect the loop as such, this is the list we are looping over:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_list <- list(\n  \"element_1\" = c(1, 4, 5, 6),\n  \"element_2\" = c(9, 2, 2, 8),\n  \"element_3\" = c(4, 3, 0, 7)\n)\n```\n:::\n\n\n\nAnd this is how the loop looks like:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresult <- rep(NA, length(base_list)) # The output container\nfor (i in seq_along(base_list)) { # The looping sequence\n  result[[i]] <- mean(base_list[[i]]) # The action body\n}\n```\n:::\n\n\n\nThe **first part** is actually located outside the for-loop in a strict sense.\nBut for the sake of efficiency, it is very important that you prepare a\nvector into which you can save the results of your loop. The vector should be\nof the same length as your loop will have iterations, and it is a good idea to\nuse a vector full of `NA`s that are then replaced during the actual loop.\nThus, the length of the output contains should equal the length of the object\nover which you are looping.\n\nThe **second part** is the looping sequence, and it determines the number of \ntimes your loop will iterate the task that is specified in the action body \nbelow. In the case above, we want to compute the mean for each element of \n`base_list`. In other words: we are looping over each element of `base_list`\nand the loop will comprise of three iterations.\n\nThe looping sequence always starts with the keyword `for` and an opening \nbracket. Then you specify a keyword that can be an (almost) arbitrary word.\nBut usually, one uses a single letter, most commonly the letter 'i'. This letter\nwill take a different value during each iteration of the loop. The value it takes\nis specified by the vector that comes after the next keyword `in`: in the case\nabove, this sequence is created by `seq_along(base_list)`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq_along(base_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n:::\n\n\n\nAs you can see it is an index vector, i.e. a vector that starts with `1`, only\ncontains subsequent integers, and has so many elements as the object that \nhas been passed as an argument to `seq_along()`.\n\nIn the case above, this means that in the first iteration of the loop, `i` takes\nthe value `1`. In the second iteration it takes the value `2`. And in the third\nand last iteration it takes the value `3`. You could make this visible by \nwriting a loop like this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in seq_along(base_list)){\n  print(i)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n[1] 2\n[1] 3\n```\n:::\n:::\n\n\n\nIn principle, the keyword of your loop can take arbitrary values. For instance\nyou could also loop over the names of `base_list`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in names(base_list)){\n  print(i)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"element_1\"\n[1] \"element_2\"\n[1] \"element_3\"\n```\n:::\n:::\n\n\n\nBut this is usually not a very good idea. It is usually best to loop over an\nindex vector of the main object of interest.\n\nThe **third part** of the loop is the action body. This is where the interesting\ncode resides in, and where you determine what should be done during each \niteration of the loop. Here, the code usually produces one result per iteration\nthat should be allocated to the output contained created in the first step.\n\nIn the present case, we wanted to compute the mean for each element of the \nlist `base_list`. Thus, our action body only consists of a call of the function\n`mean`, and then saves the result in the initial output container. If we then\ninspect the output container, we see that all the `NA`s were replaced by the \nmeans of the respective elements of `base_list`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresult <- rep(NA, length(base_list)) # The output container\nprint(result) # Only contains NAs\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA NA NA\n```\n:::\n\n```{.r .cell-code}\nfor (i in seq_along(base_list)) { # The looping sequence\n  result[[i]] <- mean(base_list[[i]]) # The action body\n}\nprint(result) # NAs were replaced by the means\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4.00 5.25 3.50\n```\n:::\n:::\n\n\n\nWhile the loop above was very simple, the basic concept is extremely powerful:\nthe action body of a loop can be of arbitrary complexity, making for loops a \nvery powerful programming tool. But caution: very complex computations take \ntime, and iterating them many times using a for-loop can take a lot of time.\n\nHere are some general tips for developing for-loops:\n\n* Before writing a long loop, write a short loop that only has two or three\niterations. Once you are sure that this reduced loop does what it was meant to\nbe you can extend the looping sequence.\n* When developing a loop, make sure that everything goes as planned by adding\nmany `print()` statements into the action body; this is especially useful for\nyour looping keyword `i` since this makes explicit what you are actually looping\nover.\n* Always loop over the indices of the object of interest, never over its elements.\nIf you just want to iterate a task, you can loop over the indices of a \nsimple sequence of the desired length. In any case, the looping sequence should\nbe built by using `seq_along()` or `seq_len()`.\n\nBefore proceeding with the tutorial, it might be a good idea to practice. \nHere are some suggestions for exercises (you find possible solutions\n[here](https://gist.github.com/graebnerc/fa3b987235ef6d4a628325bbe705de75)):\n\n1. Write a for-loop that loops over the vector `c(1,2,3,4,5)` and computes the\nsquare root for each element.\n2. Write a for loop that draws 10 numbers from a normal distribution with\nmean `0` and standard deviation `1`. You can get a single draw by calling \n`rnorm(1)`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrnorm(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -1.413075\n```\n:::\n:::\n\n\n\n3. Write a for-loop that loops over the columns of the following tibble, and \ncomputes the median of the elements in each column:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nex_tib <- tibble::tibble(\n  \"a\" = rnorm(5, mean = 5, sd = 2),\n  \"b\" = rpois(5, lambda = 3),\n  \"c\" = rcauchy(5, location = 3, scale = 2)\n)\nex_tib\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 x 3\n      a     b     c\n  <dbl> <int> <dbl>\n1  3.08     3 3.01 \n2  4.13     2 2.86 \n3  1.28     1 0.628\n4  7.20     3 4.72 \n5  3.27     4 3.05 \n```\n:::\n:::\n\n\n\n\n## The map-functions from the purrr-package\n\nThe package `purrr` provides a number of functions that are designed to \nfacilitate the development of iteration tasks. To this end, they allow you to,\nfirst, think about how to accomplish what you want to do for a single element\nof the object of interest and then, second, simply pass your solution to a \nfunction from the `map`-family and let it take care of the iteration.\n\nThe `map`-family is made up of five functions, which only differ by the type\nof output they produce: \n`map()`, which returns output in the form of a list, as well as \n`map_lgl()`, `map_int()`, `map_dbl()`, and `map_chr()`, which return output in \nthe form of an atomic vector of type \n`logical`, `integer`, `double`, and `character`, respectively.\n\nAll five functions, however, work very similarly and take the same arguments,\nwhich means: once you understood one of them you understood all of them.\nAll take two mandatory arguments: `.x` and `.f`.\nThe first argument, `.x`, specifies a vector, and the second, `.f`, a function \nthat gets applied to each element of the vector.\n\nLets consider one of the examples above: take our list `base_list` and compute \nthe mean for each of its elements. Since `base_list` is the object over which\nwe want to iterate it is passed to the function via the argument `.x`, and\nsince we want to compute the mean, we pass the function `mean()` via the \nargument `.f`. In the following case we use `purrr::map()`, so the result \nwill be a `list`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npurrr::map(.x = base_list, .f = mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$element_1\n[1] 4\n\n$element_2\n[1] 5.25\n\n$element_3\n[1] 3.5\n```\n:::\n:::\n\n\n\nIf we would like the result to be, for instance, of type `double` we simply use\n`purrr::map_dbl()` instead:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npurrr::map_dbl(.x = base_list, .f = mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nelement_1 element_2 element_3 \n     4.00      5.25      3.50 \n```\n:::\n:::\n\n\n\nSometimes you want to pass a function with optional arguments to `.f`. \nThe following application, for instance, does not compute the mean if there\nare `NA`s in the vectors:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput_vec <- list(c(1, 4, NA, 2), c(NA, NA, 3, 0), c(9, 8, 3, 4))\npurrr::map_dbl(.x = input_vec, .f = mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA NA  6\n```\n:::\n:::\n\n\n\nTo avoid this we need to set the optional argument `na.rm` of `mean()` to `TRUE`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npurrr::map_dbl(.x = input_vec, .f = ~mean(x = .x, na.rm=TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.333333 1.500000 6.000000\n```\n:::\n:::\n\n\n\nAs you can see we added a `~` in front of the function name and then passed \nto the first argument of the function the object over which we want to iterate as `.x`. \nThen we can add additional arguments as desired.\n\nIt is now a good idea to practice the use of the map-functions. Note that the\nexercises are very similar to the ones from the section on for-loops above.\nThis is because for-loops and the map-functions are geared to do the same things\njust in different ways (again, the solutions can be found \n[here](https://gist.github.com/graebnerc/fa3b987235ef6d4a628325bbe705de75)).\n\n4. Compute the square root for each element of the vector `c(1,2,3,4,5)` by \nusing a map-function from `purrr`. In the first case, your solution should \ntake the form of a list, in the second case an atomic vector of type `character`.\n\n5. Draw 10 numbers from a normal distribution with mean `2` and standard \ndeviation `4`. Again, use a map-function from `purrr´ and return the result \none time as an atomic vector of type `double` and one time of type `character`.\n\n6. Computes the median of the elements in each column of the tibble `ex_tib` as\ndefined above. The result should come in form of a `list`.\n\n# The applied part: doing Monte Carlo Simulations in R\n\nThe basic idea of a MCS is to repeat a particular random process many times.\nIt does not come to a surprise that this is not difficult to do with\nthe tools we just acquired. \n\n## The overall workflow\n\nConducting a MCS always involves the following steps:\n\n* Define the random process to be analysed\n* Repeat the random process many times\n* Summarize the simulation results\n\nTechnically, there are two alternative ways of how to implement a MCS in R:\nusing `for`-loops, or a `map`-function from the package\n[purrr](https://purrr.tidyverse.org/), as described above. \nThe latter option is clearer and more concise, the former is more \nflexible and intuitive. Below we use both alternatives, so its your choice\nof how you are conducting your own experiments.\n\n### A simple example\n\nWe start with a simple example that does not relate to the topic of sampling.\nThen we consider a more complex example and replicate the example from the\nlecture slides where we drew a sample from the ball pit.\n\nThe first example we consider is a MCS of an unfair coin. Assume we want to \nthrow the coin many times to figure our the probability for the coin to show\n'head'.\n\nIn the first step we need to **define the random process**. In the present case\nthis is the process of throwing a coin that shows 'head' with a certain \nprobability.^[In reality such an experiment only makes sense if we *do not* know\nthis probability, but here we are dealing with this situation only for the \npurpose of illustration.] \nTo this end, we define a function that does exactly this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Throwing a coin\nthrow_coin <- function(prob_head){\n  sample(c(\"Head\", \"Tail\"), size = 1, prob = c(prob_head, 1-prob_head))\n}\n```\n:::\n\n\n\nIn the second case, we **repeat the random process**. Lets do this 1000 times,\nassuming that the probability for our unfair coin to show 'head' is set to \n80%.\nUsing a for loop this would look like this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\niterations <- 1000\nprobability_head <- 0.8\noutput_container <- rep(NA, iterations)\nfor (i in seq_len(iterations)){\n  output_container[i] <- throw_coin(prob_head = probability_head)\n}\n```\n:::\n\n\n\nIf we used a map-function we would write the following:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_output <- map_chr(.x = 1:iterations, ~throw_coin(prob_head = 0.8))\n```\n:::\n\n\n\nBoth approaches accomplish the same thing. We can now **summarize** or \n**visualize the results**. We could do this by using quantitative indicators,\nbut the most common and usually most illustrative way is to use a \nhistogram. We can do this by using `ggplot2::ggplot()`, we only need to \ntransform our output container into a `tibble`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\noutput_tib <- tibble::tibble(map_output)\n\nggplot(data = output_tib, aes(x=map_output)) +\n  scale_y_continuous(expand = expansion(add = c(0, 40))) +\n  labs(y = \"Times observed\") +\n  geom_histogram(stat = \"count\") +\n  theme_bw() + theme(axis.title.x = element_blank())\n```\n\n::: {.cell-output-display}\n![](index_files/figure-pdf/unnamed-chunk-17-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n### A more complex example from sampling\n\nIn this case we want to simulate the act of drawing a sample from an artificial\npopulation of a ball pid.\n\nThis time, the first step involves the notion of a population since it\nrepresents the drawing of sample from this population. Thus, in a very first \nstep we need to create such a population. In our case, this is a ball pid \nwith 5000 balls, 65 per cent of which are white and 35 per cent of which are\ngrey:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nball_pid_size <- 5000\nball_pid_share_white <- 0.65\nwhite_balls <- as.integer(ball_pid_share_white*ball_pid_size)\ngrey_balls <- ball_pid_size - white_balls\nball_pid_colors <- c(rep(\"white\", white_balls), rep(\"grey\", grey_balls))\n\nball_pid <- tibble::tibble(\n  id = seq(1, ball_pid_size),\n  color = sample(ball_pid_colors) \n)\nhead(ball_pid, 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 x 2\n     id color\n  <int> <chr>\n1     1 grey \n2     2 grey \n3     3 white\n4     4 white\n```\n:::\n:::\n\n\n\nNow we can write a function that formalizes the act of drawing a sample \nfrom the ball pid and computing the share of white balls:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Function that takes a sample of balls and computes share of white balls\nsample_balls <- function(bowl, sample_size, replace_balls=FALSE){\n  sample_obtained <- sample(x = bowl, size = sample_size, replace = replace_balls)\n  sum(sample_obtained == \"white\") / sample_size\n}\n```\n:::\n\n\n\nWe now conduct the MCS by iterating the process of drawing such a sample \n1000 times. Suppose we want to use our MCS to study the effect of taking \nsamples of different sizes, say 20, 50, or 100. Using a for-loop this could\nlook like this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn_samples <- 1000\nresults_n20 <- rep(NA, n_samples)\nresults_n50 <- rep(NA, n_samples)\nresults_n100 <- rep(NA, n_samples)\n\nfor (i in seq_len(n_samples)){\n  results_n20[i] <- sample_balls(bowl = ball_pid$color, sample_size = 20)\n  results_n50[i] <- sample_balls(bowl = ball_pid$color, sample_size = 50)\n  results_n100[i] <- sample_balls(bowl = ball_pid$color, sample_size = 100)\n}\n\nresult_table <- tibble(\n  sample_size20 = results_n20,\n  sample_size50 = results_n50,\n  sample_size100 = results_n100\n)\n```\n:::\n\n\n\nA variant with a map-function would look like this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresults_n20_map <- purrr::map_dbl(\n  .x = 1:n_samples, \n  .f = ~sample_balls(bowl = ball_pid$color, sample_size = 20))\n\nresults_n50_map <- purrr::map_dbl(\n  .x = 1:n_samples, \n  .f = ~sample_balls(bowl = ball_pid$color, sample_size = 50))\n\nresults_n100_map <- purrr::map_dbl(\n  .x = 1:n_samples, \n  .f = ~sample_balls(bowl = ball_pid$color, sample_size = 100))\n```\n:::\n\n\n\n\n> **Should we create a new population for during each iteration?**\nIt depends on the question asked. If you are interested in one particular \npopulation, you should keep this population fixed over all iteration. However,\nif you are interested in more general results for a population that itself \ninvolves random noise, it might be appropriate the re-generate the population\nfor each iteration of your simulation. In the cases considered here, however,\nwe can treat the population as fixed.\n\nWe can now visualize our results using a histogram:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhist_visualization <- result_table %>%\n  pivot_longer(cols = everything(), \n               names_to = \"Sample size\", \n               values_to = \"Share of white balls\") %>%\n  mutate(\n    `Sample size` = as.integer(\n      stringr::str_remove_all(`Sample size`, \"[^0-9.-]\"))\n    ) %>% \n  ggplot(data = ., aes(x=`Share of white balls`)) +\n  geom_histogram(binwidth = 0.02, fill=\"#00395B\") +\n  scale_y_continuous(expand = expansion(add = c(0, 1))) +\n  scale_x_continuous(labels = percent_format()) +\n  labs(\n    x = \"Share of white balls\", \n    y = \"Number of samples\", \n    title = \"True share: 65%\") +\n  geom_vline(xintercept = 0.65) +\n  facet_wrap(~`Sample size`, scales = \"fixed\") +\n  theme_icae() +\n  theme(\n    panel.grid.minor.x = element_blank(), \n    panel.grid.minor.y = element_blank())\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhist_visualization\n```\n\n::: {.cell-output-display}\n![](index_files/figure-pdf/unnamed-chunk-23-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nOf course, we could also illustrate the result quantitatively:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresult_table %>%\n  pivot_longer(cols = everything(), \n               names_to = \"Sample size\", \n               values_to = \"Share of white balls\") %>%\n    mutate(\n    `Sample size` = as.integer(\n      stringr::str_remove_all(`Sample size`, \"[^0-9.-]\"))\n    ) %>%\n  group_by(`Sample size`) %>%\n  summarise(\n   `Mean share` = mean(`Share of white balls`),\n    `Standard deviation` = sd(`Share of white balls`)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 x 3\n  `Sample size` `Mean share` `Standard deviation`\n          <int>        <dbl>                <dbl>\n1            20        0.648               0.105 \n2            50        0.653               0.0684\n3           100        0.652               0.0485\n```\n:::\n:::\n\n\n\n# Useful functions in the context of MCS\n\nWe end this tutorial by providing an overview over a number of functions that\nare usually extremely useful in the context of MCS, or analyzing random \nprocesses more generally:\n\nWe already encountered the function `sample()`, which we can use to draw random\nsamples: as a first argument `x` \nit accepts a vector, from which you can then draw random samples. \nThe second argument, `size`, controls the size of the sample. You can \neither draw random samples with or without replacement by specifying the\noptional argument `replace`, and you can set probabilities to draw a particular\nelement of `x` by giving a vector of probabilities via `prob`.\n\nWhen you want to simulate random draws from a particular distribution, `R` \ncomes with a very handy syntax: different probability distributions all have\ntheir own abbrevation and depending what you want to do with this distribution\nyou just put a letter in from of this abbrevation. If, for instance, you want\nto draw a random element from such a distribution you just add the letter `r`.\n\nFor instance, if you want to simulate a draw from a normal distribution you\nadd `r` to the abbrevation of the normal distribution, which is `norm`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrnorm(n = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  0.62615253  0.44402388 -0.33896029  0.09500515 -0.10525423\n```\n:::\n:::\n\n\n\nIf you want to draw from an exponential distribution you add `r` to the \nabbrevation for the exponential distribution, which is `exp`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrexp(n = 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.34480404 1.98339789 0.74375079 0.09611437\n```\n:::\n:::\n\n\n\nIn fact, here is an overview over the various prefixes you can use:\n\n* `p` for \"probability\", the cumulative distribution function (CDF)\n* `q` for \"quantile\", the inverse CDF\n* `d` for \"density\", the density function (PDF)\n\nTo get the CDF for a particular quantile of the normal distribution you can do:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npnorm(q = 0.25)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.5987063\n```\n:::\n:::\n\n\n\nHere you find an overview over the abbrevations for some of the most common\ndistribution, but its easy to find additional information in the internet as \nwell:\n\nDistribution | Kind       | Abbrevation | Parameters     |\n-------------+------------+-------------+----------------|\nBinomial     | Discrete   | `binom`     | `size`, `prob` |\nPoisson      | Discrete   | `pois`      | `lambda`       |\nUniform      | Continuous | `punif`     | `min`, `max`   |\nNormal       | Continuous | `norm`      | `mean`, `sd`   |\nExponential  | Continuous | `exp`       | `rate`         |\n\nAbsolutely essential is the function `set.seed()`. It allows us set a particular \nvalue for the random number generator of `R`. You can read more about how \n`R` actually creates random numbers using a pseudo random number generator\ncalled the [Mersenne Twister](https://en.wikipedia.org/wiki/Mersenne_Twister).\nBut the general take away is the following: random numbers in R are only \n'pseudo' in the sense that whenever the Mersenne Twister starts from the same\nlocation it produces the same random numbers. And `set.seed()` lets you pick\nthis starting point. This is important because it makes MCS reproducible.\n\nTo illustrate this, consider the function `rnorm()`, which creates draws from\na normal distribution. If we just call the function the result is always \ndifferent due to the Mersenne Twister algorithm:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrnorm(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -0.4702105  0.5862862 -0.6993448  0.9873997  2.3716115\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nrnorm(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -0.651579 -1.032944  0.852567  0.919649 -0.153983\n```\n:::\n:::\n\n\n\nBut if we set the seed for the Mersenne Twister explicitly, the outcome \nbecomes reproducible:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\nrnorm(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -0.56047565 -0.23017749  1.55870831  0.07050839  0.12928774\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\nrnorm(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -0.56047565 -0.23017749  1.55870831  0.07050839  0.12928774\n```\n:::\n:::\n\n\n\nThis is extremely useful if we want to keep our results reproducible.\n",
    "supporting": [
      "index_files/figure-pdf"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}