{
  "hash": "b7cc4bc5ddbac97e81107fde0eee6625",
  "result": {
    "markdown": "---\ntitle: First steps in R # Also check out line 43\nauthor: Claudius Gräbner-Radkowitsch\ndate: '2024-03-21'\ndocumentclass: scrartcl\nexecute: \n  freeze: auto\nformat: \n  html:\n    theme: readable\n    highlight: tango\n    toc: true\n    toc_depth: 2\n    number_sections: true\n  pdf:\n    papersize: a4\n    toc: true\n    toc-depth: 2\n    number-sections: true\n    include-in-header: \n      text: |\n        \\usepackage{lmodern} \n        \\usepackage{graphicx}\n        \\usepackage{hyperref}\n        \\usepackage{url}                \n        \\usepackage{xcolor}\n        \\usepackage{booktabs}\n        \\usepackage{listings}\n        \\lstloadlanguages{R}\n        \n        \\definecolor{eufblue}{RGB}{0,57,91}\n        \\definecolor{eufgrey}{RGB}{111,111,111}\n        \\definecolor{euflightblue}{RGB}{105,170,205}\n        \n        \\hypersetup{\n        pdfauthor={Claudius Graebner-Radkowitsch}\n        colorlinks=true,\n        linkcolor=euflightblue,\n        urlcolor=euflightblue\n        }\n        \\usepackage[includehead,includefoot,top=2cm, bottom=1.5cm]{geometry}\n        \\usepackage[headsepline, footsepline]{scrlayer-scrpage}\n        \\pagestyle{scrheadings}\n        \\clearpairofpagestyles\n        \\ihead{Tutorial: First steps in R}\n        %\\chead{Kopfzeile Mitte}\n        \\ohead{\\pagemark} %\n        \\ifoot{}\n        \\cfoot{\\href{https://euf-datascience-spring24.netlify.app/}{\\normalfont\\color{eufblue}{Data Science Using R - Spring Semester 2024}}} % Fußzeile Mitte\n        \\ofoot{} \n        \\setkomafont{disposition}{\\color{eufblue}\\bfseries}\n---\n\n\n\n::: {.cell}\n\n:::\n\n\n\nIn this post we will learn about the basic *syntax* of R.\nThe syntax basically refers to the grammatical rules you must adhere to when \ncommunicating with your computer in the language `R`: if you do not follow \nthe right syntax, i.e. you 'speak' grammatically incorrect, your computer will \nnot understand you and communicate this to you by throwing up an error message.\n\nTo learn about these important basics, the post follows the following structure:\n\n* Commands\n* Objects, functions, and assignments\n* R packages\n\n# Issue commands to your computer\n\nThere are two ways we can communicate with our computer in \nR Studio: either issuing commands directly via the *console*, \nor by executing a script.^[If you do not know what the console is, you \nshould have a look at the lecture slides from the [Material section](/material/)\nagain.]\n\nLets start by using the console and use `R` as a simple calculator first: \nwe first want to add the numbers `2`and `5`.\nTo this end, simply type `2 + 5` into the console and press `Enter`. \nSince the expression `2 + 5` is syntactically correct `R` code, the \ncomputer 'understands' what we want from it and returns the result:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n2 + 5\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] 7\n```\n:::\n:::\n\n\n\nThe `#>` at the beginning of the line indicates that what is written on this \nline is the output of an R command (but the concrete sign might be different \non your computer). \n\nThe result of `2 + 5` is a number (more precisely: a 'scalar'). \nIn `R`, scalars are always represented as a *vector* of length 1.\nThe `[1]` here indicates that the first element on this line is the first \nelement of the vector. In the present case, the first element is the only \nelement of the vector, since it contains only one element (which is what a \nscalar is in the first place in `R`: a vector with one element).\nIf the result of our calculation was a very long vector that\nneeds to span several lines, at the beginning of the next line R would show us \nthe index of the first number displayed on this line.^[You may try this out by \n  typing `1:100` into your console and see what happens: this returns a vector \n  of length 100, which certainly will contain some line breaks.]\n\nIn this way we can use R as a simple calculator: \nall basic mathematical operations have their own symbol as operator, i.e. a \nsignal token that tells the computer to implement a certain computation.\n\nAt this point it should be pointed out that the symbol `#` in R introduces \na *comment*, that means everything in a line after `#` will be ignored by the \ncomputer and you can make notes in the code that only help *you* \n(or other humans) to understand what you have written.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n2 + 5 # Addition\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] 7\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n2/2 # Division\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] 1\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n4*2 # Multiplication\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] 8\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n3**2 # Exponentiation\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] 9\n```\n:::\n:::\n\n\n\nComments are usually not very useful whenever you use the console to execute \n`R` code, but they come in handy when you are writing *scripts*:\nan alternative to typing the commands into the console and then press `Enter`\nto execute them, is to write down the commands in a script, and then to execute \nthis script.^[Again, the use of scripts has been explained in the lecture, so\nhave a look at the slides (or the R-Studio cheat sheet) in the \n[Material section](/material/).\n]\n\nWhile the interaction via the console is useful to test the effects of certain \ncommands, scripts are useful whenever we want to develop more complex operations, and\nsave what you have written for later, or to make them accessible to other people:\nwe can save scripts as a file on our computer, and then use them any time in \nthe future.\n\nThe operations that we have conducted so far are not particularly exciting, to\nbe honest. Before we proceed with more complex operations, however, we need to\nunderstand the ideas of `objects`, `functions`, and `assignments`.\n\n# Objects, functions, and assignments\n\n> To understand computations in R, two slogans are helpful:\n>   Everything that exists is an object.\n>   Everything that happens is a function call.\n> \\hfill John Chambers\n\nThe statement 'Everything that exists is an object.' means that every number,\nfunction, letter, or whatever there is, is an object that is stored somewhere\nin the physical memory of your computer.\nFor instance, in the computation \n`2 + 3`, the number `2` is as much an object as the number `3`\nand the addition-function, which we call via the operator `+`.\n\nThe statement 'Everything that happens is a function call.' means that whenever\nwe tell our computer to do something via `R`, we are effectively calling a \n*function*.\n\n**Functions** are algorithms that apply certain routines to an *input* and \nproduce an *output*. \nThe addition function we called in the calculation `2 + 3` took as input the \ntwo numbers `2` and `3`, applied to them the addition routine and produced the \nnumber `5` as output.\nThe output `5` is an object in `R` just like the inputs `2` and `3`, \nas well as the addition function.\n\nA 'problem' is that in the present case `R` prints the output of the calculation \nbut we have no access to it afterwards:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n2 + 3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] 5\n```\n:::\n:::\n\n\n\nIt is stored, for some time, on the physical memory of our computer, but we\nbasically have no idea where way to find it. To address this problem we can issue an \n*assignment*: whenever we want to keep using the output of an operation, we may\ngive the output a *name*. This name works effectively as a kind of pointer, \nwhich points to the place on the computer memory where the output is saved.\nThis way, we can access, and reuse it whenever we call the name. The process of\ngiving a name to an object is called *assignment*, and it is effectuated via the\nfunction `assign`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nassign(\"intermediate_result\", 2 + 3)\n```\n:::\n\n\n\nWe explain the process of calling a function in more detail below. Here we focus\non the process of assignment instead. What the function `assign` does is the \nfollowing: it assigns the name `intermediate_result` to the result of the \noperation `2 + 3`. We can now call this result by writing its name into the \nconsole and press `Enter`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nintermediate_result\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] 5\n```\n:::\n:::\n\n\n\nSince making assignments happens so frequently in practice, there is a shortcut\nto the use of the function `assign`, namely the operator `<-`.\nThus, the following two commands do effectively the same thing:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nassign(\"intermediate_result\", 2 + 3)\nintermediate_result <- 2 + 3\n```\n:::\n\n\n\nFrom now on, we will only use the `<-` operator, which also represents\nquite nicely the idea of assignments as pointers to certain objects.^[In theory \nwe can use `<-` also the other way around: `2 + 3 -> intermediate_result`.\nAt first sight this is more intuitive and respects the sequence of events:\nfirst, the result of `2 + 3` gets created, i.e. a new object gets defined.\nThen, this object gets the name `intermediate_result`.\nHowever, the code that results from such practice is usually much more difficult\nto read, so it is common practice to use `<-` rather than `->`.] \n\n> **Digression: why `<-`?** \nThe use of the string `<-` as an assignment operator is, at first sight, \nunintuitive, uncomfortable, and rather unique in the world of programming languages. \nMuch more common is the use of `=`. Where does this particularity of R come from? \nBesides practical reasons -- in contrast to `=`, the use of `<-` makes explicit\nthe unidirectionality of an assignment -- the main reason is historical: \n`R` originated from the programming language `S`. This in turn has taken over \nthe `<-` from the language `APL`. And `APL`, in turn, was developed on a keyboard \nlayout, where `<-` had its own key. Moreoever, the operator `==` was not \ncommonly used at that time and `=` was already used to test for equality \n(which, today, is basically always done by using `==`).\nAnd so one has decided to use `<-` as an assignment operator and while since \n2001 you can also make assignments in R using `=`, `<-` remains strictly \nrecommended for the sake of readability as well as some technicalities.\n\nYou are not allowed to give names to objects as you wish. All syntactically \ncorrect names in R...\n\n* only contain letters, numbers, or the symbols `.` and `_`\n* do not start with `.` or a number \n\nMoreover, there are some reserved words that you must not (and cannot) use as\nnames, e.g. `function`, `TRUE`, or `if`. You can have a look at the complete\nlist of forbidden words by calling `?Reserved`.\n\nThere is, however, nothing to remember since whenever you try to give an object\na name that conflicts with the rules just described, R immediately throws an\nerror message:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTRUE <- 5\n```\n\n::: {.cell-output .cell-output-error}\n```\n#> Error in TRUE <- 5: invalid (do_set) left-hand side to assignment\n```\n:::\n:::\n\n\n\nThere are, however, some rules that determine what is a *good* name and that\nyou should adhere to whenever possible:\n\n* Names should be short and informative; `sample_mean` is a good name, `vector_2` not so much\n* You should **never use special characters**, especially *Umlaute*\n* R is *case sensitive*, meaning that `mean_value` is a different name than `Mean_Value`\n* Even if this is possible you should never use names that are already used for\nfunctions provided by R. For instance, an assignment such as `assign <- 2` \nis possible, but it effectively prevents you from using the function `assign` \nwithout further complications.\n\n> **Note**: You can have a look at all current assignments in the `Environment`\npane in R-Studio, or list them by calling `ls()`\n\n> **Note**: One object can have more than one name, but no name can ever point\nto two object. If you re-assign a name, the old assignment will be overwritten:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 2 \ny <- 2 # The object 2 now has two names\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] 2\n```\n:::\n\n```{.r .cell-code}\nprint(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] 2\n```\n:::\n\n```{.r .cell-code}\nx <- 4 # The name 'x' now points to '4', not to '2'\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] 4\n```\n:::\n:::\n\n\n\n> **Note**: As you might have experienced, R does not return results after \nmaking an assignment:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n2 + 2 # No assignment, R returns the result in the console\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] 4\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 2 + 2 # Assignment, R does not return the results in the console\n```\n:::\n\n\n\nIf you want to remove an assignment you can use the function `rm()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 2\nrm(x)\nx\n```\n\n::: {.cell-output .cell-output-error}\n```\n#> Error in eval(expr, envir, enclos): object 'x' not found\n```\n:::\n:::\n\n\n\nYou can remove all assignment by clicking\non the broom in the upper right environment panel in `R`-Studio or\nby calling the following command:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrm(list=ls())\n```\n:::\n\n\n\n# R packages\n\nPackages are a combination of `R` code, data, documentation and tests.\nThey are the best way to create reproducible code and make it available\nto others.The fact that many people solve problems by developing \nroutines, then generalizing them and making them freely available to the whole\n`R` community is one of the main reasons for the success and wide applicability \nof `R`.\n\nWhile packages are often made available to the public, e.g. via GitHub\nor CRAN, it is equally useful to write packages for private use, \ne.g. to write functions implementing certain routines that you use frequently\nacross different projects, document them, and make them available to use \nin different projects.^[[Wickham and Bryan (2022)](https://r-pkgs.org/)\nprovide an excellent introduction to the development of R packages].\n\nWhen one starts `R` on our computer we have access to a certain number of functions,\npredefined variables, and data sets. The totality of these objects is\nusually called `base R`, because we can use all the functionalities\nimmediately after installing R on our computer.\n\nThe function `assign`, for instance, is part of `base R`: we start R and \ncan use it without further ado.\nOther functions, such as `Gini()` are not part of `base R`: they were written\nby someone else, and before using them we need to install the package\nthat contains the function definition on our computer. The function `Gini()`,\nfor instance, belongs to the package `ineq`.\n\nTo use a package in `R`, it must first be installed.\nFor packages that are available on the central `R` package platform CRAN,\nthis is done with the function `install.packages()`.^[Packages not released\non this platform can also be installed directly from the repository they were\npublished, e.g. Github. To this end, the package `remotes` must be installed\nfirst, then you can use functions such as `install_github()`. \nA short manual is provided [here](https://github.com/r-lib/remotes).] \nFor example, if we want to install the package `ineq` (which contains the \nfunction `Gini()`) this is done with the following command: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"ineq\")\n```\n:::\n\n\n\nThe package collects a number of functions that allow us to compute common \ninequality indicators, such as the Gini index.\n\nAfter having installed the package, we have to options to access the objects\nthat are defined within this project. The first option is to use the operator\n`::`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1,4,5,6,12.9)\ny <- ineq::Gini(x)\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] 0.3570934\n```\n:::\n:::\n\n\n\nHere we write the name of the package, directly followed by `::` and then \nthe name of the object that we want to use. In this example we want to use\nthe function `Gini()`, which computes the Gini index.\n\nIf we ommited the `::`, `R` did not look into the package `ineq` and, therefore,\nwould not able to find the function, returning an error:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- Gini(x)\n```\n\n::: {.cell-output .cell-output-error}\n```\n#> Error in Gini(x): could not find function \"Gini\"\n```\n:::\n:::\n\n\n\nUsing `::` is the most transparent and safest way to access objects defined in \na package: you immediately see where the object is coming from. At the same \ntime it can be tedious to write the package name so many times, especially if\nyou use many objects from the same package. In this case we can make available\nall objects from the package by calling the function `library()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ineq)\ny <- Gini(x)\n```\n:::\n\n\n\nThis process is called *attaching a package*.\nFor the sake of clarity, you should always add a call of `library()` for \nall packages used within a script *at the very top of the script*. \nThis way you can see immediately which packages must be installed such that the\nscript works.\n\nIn principle, only the packages that are actually used should be read into \neach script with `library()`. \nOtherwise you will unnecessarily load a lot of\nobjects and lose track of where a certain function actually comes from. \nIn addition, it is more difficult for others to use the script because \nmany packages have to be installed unnecessarily.\n\nSince packages are produced decentrally by a wide variety of people, there is a\ndanger that objects in different packages get the same name.\nSince in `R` a name can only point to one object, names may be overwritten or \n'masked' when loading many packages. \nWhile R informs you about this happening when you attach a package, it is easily \nforgotten and can result in very cryptic error messages. \n\nWe will illustrate this briefly using the two packages `dplyr` and `plm`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(plm)\n```\n:::\n\n\n\nBoth packages define objects with the names `between`, `lag` and `lead`.\nWhen attaching packages using `library()`, the later package masks the objects\nof the earlier package. You see this by calling the objects by name:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlead\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> function (x, k = 1L, ...) \n#> {\n#>     UseMethod(\"lead\")\n#> }\n#> <bytecode: 0x7fad7094f9e0>\n#> <environment: namespace:plm>\n```\n:::\n:::\n\n\n\nThe last line informs is about the fact that the function was defined in the\npackage `plm`. If we now want to call the function `lead` from the package\n`dplyr`, we must use `::`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::lead\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> function (x, n = 1L, default = NULL, order_by = NULL, ...) \n#> {\n#>     check_dots_empty0(...)\n#>     check_number_whole(n)\n#>     if (n < 0L) {\n#>         abort(\"`n` must be positive.\")\n#>     }\n#>     shift(x, n = -n, default = default, order_by = order_by)\n#> }\n#> <bytecode: 0x7fad709f2588>\n#> <environment: namespace:dplyr>\n```\n:::\n:::\n\n\n\nThis can be very confusing. Thus, I *strongly recommend* to *always* use `::` \nwhen it comes to masking, no matter whether it is stricly necessary or not.\nIn this case, always use `plm::lead` and `dplyr::lead`, even if it was not \nrequired in the first case. Otherwise, your code becomes very difficult to \nunderstand and breaks completely once you change the sequence of the library \ncalls in the beginning.\n\n> **Hint**: You can show all object that are affeceted by conflicting names via\nthe function `conflicts()`.\n\nFor the sake of transparency I will always use the notation with `::` whenever\nI refer to an object that is not defined in `base R`. Only in the case of \nobjects that are part of base I will stick to only writing the object name.\n\n> **Digression**:  In order to check the order in which R searches for objects, \nthe function `search()` can be used. When an object is called by its name\nR first looks in the first element of the vector, the global environment.\nIf the object is not found there, it looks in the second, and so on. \nAs you can also see here, some packages are read in by default.\nIf an object is not found anywhere, R gives an error. \nIn the present case, the function shows us that R only looks in the package \n`plm` for the function `lead()`, and not in the package `dplyr`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsearch()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#>  [1] \".GlobalEnv\"        \"package:plm\"       \"package:dplyr\"    \n#>  [4] \"package:ineq\"      \"package:bit64\"     \"package:bit\"      \n#>  [7] \"package:tufte\"     \"package:stats\"     \"package:graphics\" \n#> [10] \"package:grDevices\" \"package:utils\"     \"package:datasets\" \n#> [13] \"package:methods\"   \"Autoloads\"         \"package:base\"\n```\n:::\n:::\n\n\n\n> **Further information**: To better understand masking you might want to learn\nabout the concepts of *namespaces* and *environments*. \n[Wickham and Bryan (2022)](https://r-pkgs.org/) is an excellent \nsource to do so.\n\n# Taking stock\n\nLets recap what we have learned so far about issuing commands, names and \nassignments:\n\n* We can issue commands to the computer in R by (a) typing R code into the \nconsole and press `Enter`, or (b) write the code into a script and then execute \nit\n* Everything that *exists* in R is an *object*, everything that *happens* is a\n*function* call\n* A function is an object that takes an input, applies a certain routine, and\nreturns an output\n* We can assign an object a name by using `<-`. Then we can call this object by\ntyping its name. The process of giving a name to an object is called *assignment*,\nand we can have a look at all names currently given to objects by calling `ls()` \n* R packages are bundles of objects and functions created by others and made\navailable to the R community. After installing packages, we can access their\nobjects via `PackageName::ObjectName`, or by attaching the package via\n`library(PackageName)`\n\nFinally, I want to point your attention to the function `help()`, which \ncan provide you with additional information about the object a name points to.\nFor instance, if you want to get more information about the function with the\nname `assign`, then just type the following: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhelp(assign)\n```\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}