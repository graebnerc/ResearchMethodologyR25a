{
  "hash": "5911f3c3e6ab9da1d4220053a9e10606",
  "result": {
    "markdown": "---\ntitle: \"Fundamental object types in R II: Vectors\" # Also check out line 43\nauthor: Claudius Gräbner-Radkowitsch\ndate: '2024-03-28'\ndocumentclass: scrartcl\nformat: \n  html:\n    theme: readable\n    highlight: tango\n    toc: true\n    toc_depth: 2\n    number_sections: true\n  pdf:\n    papersize: a4\n    toc: true\n    toc-depth: 2\n    number-sections: true\n    include-in-header: \n      text: |\n        \\usepackage{lmodern} \n        \\usepackage{graphicx}\n        \\usepackage{hyperref}\n        \\usepackage{url}                \n        \\usepackage{xcolor}\n        \\usepackage{booktabs}\n        \\usepackage{listings}\n        \\lstloadlanguages{R}\n        \n        \\definecolor{eufblue}{RGB}{0,57,91}\n        \\definecolor{eufgrey}{RGB}{111,111,111}\n        \\definecolor{euflightblue}{RGB}{105,170,205}\n        \n        \\hypersetup{\n        pdfauthor={Claudius Graebner-Radkowitsch}\n        colorlinks=true,\n        linkcolor=euflightblue,\n        urlcolor=euflightblue\n        }\n        \\usepackage[includehead,includefoot,top=2cm, bottom=1.5cm]{geometry}\n        \\usepackage[headsepline, footsepline]{scrlayer-scrpage}\n        \\pagestyle{scrheadings}\n        \\clearpairofpagestyles\n        \\ihead{Tutorial: Vectors}\n        %\\chead{Kopfzeile Mitte}\n        \\ohead{\\pagemark} %\n        \\ifoot{}\n        \\cfoot{\\href{https://euf-datascience-spring24.netlify.app/}{\\normalfont\\color{eufblue}{Data Science Using R - Spring Semester 2024}}} % Fußzeile Mitte\n        \\ofoot{} \n        \\setkomafont{disposition}{\\color{eufblue}\\bfseries}\n---\n\n\n\n\n# Overview\n\nWe already learned that everything in R that exists is an *object*.\nYou most likely noted that there are different types of objects:\n`2`, for instance, was a number, but `assign` was a function.^[In fact, \nwe will learn below that `2` is not really a number, but a vector\nor length 1. Only in a next step, `2` counts as a 'number', or, more precisely\nas a 'double'.]\nAs you might have guessed, there are many more types of objects. \nTo understand the fundamental object types in R is an essential prerequisite\nto master more complicated programming challenges than those we have encountered\nso far. Thus, this post is among those that will introduce you to the most \nimportant object types that you will encounter in R. \n\nThese data types are summarized in the following figure:\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](vector-classification.pdf)\n:::\n:::\n\n\n\nThis post will be about the most common types of vectors.\nSee the [previous post](/tutorial/object-types-func/) \nfor a treatment of functions, and the \n[upcoming one](/tutorial/object-types-adv/) \nfor more advanced types of vectors, such as `factor`, `matrix`, and `data.frame`.\n\n# Vectors\n\nVectors are the most important object type in `R` - almost all data that we will\nwork with in `R` are vectors of some sort. Within the class of vectors, the most\nimportant distinction is that between **atomic vectors** and **lists**, which\nare sometimes also called *generic vectors*.^[The only object type that is\nof relevance to us aside these two is `NULL`. We will learn about it during\nthe end of this post.]\nBoth atomic vectors and lists consist of one or more other objects. What \ndistinguishes the two is that while\n*atomic vectors are composed only of objects of the same type*, lists can \ncomprise objects of different types.\n\n## Atomic vectors\n\nThis makes it easy to classify atomic vectors in more detail: we usually say \nthat the type of atomic vector is the type of the object it encompasses.\nFour major types of atomic vectors in this sense exist:\n\n* `logical` (logical values): there are only two relevant logical values: \n`TRUE` und `FALSE`^[While you can abbreviate the two with `T` and `F`, respectively,\nI recommend against using these sometimes ambiguous abbreviations.]\n* `integer` (whole numbers): this type should be self-explanatory. Less \nintuitive is the rule that in order to define an integer in `R` you need to type\nthe number followed by the letter `L` such that `R` interprets the number \nas an integer.^[This syntax has historical reasons: when the type `integer`\nwas introduced in `R`, the developers were guided by the type `long integer` of\nthe programming language `C`. In `C` the suffix for such an integer was 'l' or\n'L'. The R developers just transferred this practice into `R`, only they \ndid not use 'i' to avoid a possible confusion between 'l' and 'i', which look\nvery similar in many fonts (the suffix 'i' in `R` is used for the imaginary\ncomponent of complex numbers).] Examples are `1L`, `-400L` or `10L`.  \n* `double` (decimal numbers): these should be self-explanatory as well. \nExamples are `1.5`, `0.0`, or `-500.32`.\n* Whole and decimal numbers are often summarized in the category `numeric`.\nHowever, the use of `numeric` is almost always confusing, and many functions \nshow counter-intuitive behavior when this category is used. I recommend you to \nnever use it.\n* `character` (words): these can contain all kinds of tokens and are characterized\nby the fact that they always start and end with `\"` (or `'`). Examples would be\n`\"Hello\"`, `\"500\"` or `\"1_2_Three\"`.\n\nAs indicated above, an atomic vector only comprises elements of the same type.\nIn this context, we should mention, however, the at first sight 'strange' \ndata type `NA`, which denotes a missing value:^[In principle there are different \nkinds of missing values, such as `NA_integer_` or `NA_character_`, but they are\nirrelevant in practice: any `NA` value in an atomic vector automatically \n'mimics' the type of the atomic vector.]\nwhenever an element of a vector is missing, e.g. when the vector is used to \nstore observations of subjects that have participated in an experiment, and \nfor some subjects the observation is \nmissing, we will use `NA`.^[`NULL` on the other hand, is used to represent an \nabsent vector, not an absent element of a vector. We will come back to `NULL` \nduring the end of the post.]\n\n### Testing and coercing types \n\nIn the following we will study the different types of atomic vectors and their\ntypical behavior in more detail. But before doing so we should introduce the \nfunction `typeof()`: it helps us to identify the type of an object in the first \nplace. To see how, lets call the function with the object (or the name of the\nobject) we are interested about:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(2L)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 22.0\ntypeof(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n:::\n\n\n\nThere is also a family of functions that allows us to test whether an object\nis actual of a certain type or not. The general syntax here is `is.*()`. \nFor instance:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1.0\nis.integer(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nis.double(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n\nThis function always returns an object of type `logical`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- is.double(x)\ntypeof(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"logical\"\n```\n:::\n:::\n\n\n\nWe can also try to transform objects from one type into another. \nWe call this process 'coercion' an the general syntax is `as.*()*`.\nFor instance:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- \"2\"\nprint(\n  typeof(x)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\nx <- as.double(x)\nprint(\n  typeof(x)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n:::\n\n\n\nSuch a transformation is, however, not always possible:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.double(\"Hello\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: NAs introduced by coercion\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n\n\nSince `R` does not know how to turn the word 'Hello' into a decimal number, \nit transforms it into a 'missing value' - `NA`.\n\nFor the basic types discussed above there is a logical hierarchy of feasible\ntransformations:\n`logical` &rarr; `integer` &rarr; `double` &rarr; `character`,\nmeaning that you can always transform a decimal number into a word, but not\nvice versa.\n\n> **Transgression: Why change the types of objects anyway?**\n> Data types are extremely important for a programming language because \notherwise it would remain unclear how mathematical operations could be \napplied to different objects such as numbers or words.\nYou will transform objects yourself especially when you want to use a certain \noperation that is only defined for a certain type of object, and the object\nyou are dealing with has been stored as a different type.\nThis can happen, for example, when you read in data or translate words into \nnumerical values yourself.\nIf unexpected errors occur in your code with cryptic error messages, it is\nalways a good idea to check the types of the objects used and transform them \nif necessary.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 2\ny <- as.character(x)\nprint(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2\"\n```\n:::\n\n```{.r .cell-code}\nz <- as.double(y) # This works\nprint(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n```{.r .cell-code}\nk <- as.double(\"Hallo\") # This does not work\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: NAs introduced by coercion\n```\n:::\n\n```{.r .cell-code}\nprint(k)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n\n\nWhen transforming logical values, `TRUE` counts as `1` and `FALSE` as `0`, \na fact that will come in handy later on:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- TRUE\nas.integer(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- FALSE\nas.integer(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n:::\n\n\n\nSince it is not always clear when `R` issues a warning for transformations\nthat are incompatible with the hierarchy just introduced and when it does not, \nyou should always be cautious!\n\nMoreover, transformations might change the properties of the transformed objects\nimplicitly in unexpected ways. \nFor instance, a transformation from a decimal number to a whole number can lead\nto unexpected rounding behavior:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1.99\nas.integer(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n\n\nAnother example is the following:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz <- as.logical(99)\nprint(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n\nSuch implicit changes of the object properties do not necessary come with a \nwarning message, so one should always be careful when transforming objects!\n\nIn many cases, functions do the necessary transformations of their arguments\nautomatically. In most cases this is very practical:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1L # Integer\ny <- 2.0 # Double\nz <- x + y\ntypeof(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n:::\n\n\n\nBut it can be dangerous in some cases as well.\n\nWhen adding up logical values they are transformed to numbers:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- TRUE\ny <- FALSE\nz <- x + y # TRUE counts as 1, FALSE as 0\nprint(z) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n\n\nThis is useful if you want to know, for instance, how many elements of a vector\nmeet a certain logical criterion:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1,2,3,4,5)\nsum(x > 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n:::\n\n\n\nIn all these cases it is very important to stay informed about the types of \nobjects you are dealing with. To help you out, the following table contains \nan overview over the most important transformation and test functions:\n\nType      | Test           | Transformation |\n----------+----------------+----------------|\nlogical   | `is.logical`   | `as.logical`   |\ndouble    | `is.double`    | `as.double`    |\ninteger   | `is.integer`   | `as.integer`   |\ncharacter | `is.character` | `as.character` |\nfunction  | `is.function`  | `as.function`  |\nNA        | `is.na`        | NA             |\nNULL      | `is.null`      | `as.null`      |\n\nA final remark on **scalars**:\nwith scalar we usually refer to 'single numbers', such as `2`.\nThere is no such concept in R: `2` is a vector with one element \n(or: of length 1).\nThus, we do not distinguish the type of a vector with or more than one\nelements.\n\n\n**Note:** As you might have guessed already, we use the function `c()` to \ncreate longer vectors:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 2, 3)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n:::\n\n\n\nWe can also use this function to concatenate vectors:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:3 # Shortcut for: x <- c(1, 2, 3)\ny <- 4:6\nz <- c(x, y)\nz\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5 6\n```\n:::\n:::\n\n\n\nSince atomic vectors can only contain objects of the same type, one might expect\nthe following code, which tries to concatenate objects of different types, to\nproduce an error:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, \"Hallo\")\n```\n:::\n\n\n\nBut this is not what happens! R transforms the objects according to the \nhierarchy discussed above:  \n`logical` &rarr; `integer` &rarr; `double` &rarr; `character`. \nDue to the absence of errors or warning messages, such operations are a\nregular source for mistakes.\n\n**Note:** The length of a vector corresponds to its numbers of elements. We\ncan 'measure' its length using the function `length()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx =  c(1, 2, 3)\nlen_x <- length(x)\nlen_x\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n\n\n> **Transgression: How large can an integer become?**\nIn R, objects of type `integer` are stored as 32-bit files.\nThis means that for each single `integer`, 32 bits of storage are available on\nyour computer. This implies that really large numbers cannot be stored as \nintegers, simply because the 32 bits are not sufficient: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 2147483647L\ntypeof(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- 2147483648L\ntypeof(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n:::\n\n\n\n> As you can see, the largest number that we can store as 32-bit integer is\n2147483647. Larger numbers must be stored as `double`. The drawback of saving\nnumbers in this type is, however, the risk of a loss of precision. If you \nwant to avoid this you could try to save an integer as a 64 bit integer.\nThis possibility has been added to R later to save large numbers as integers\n(something that happens faster than you think).\nTo do so we must use the package^[If you are not sure what a package is, \nrecap the last chapter of the post on [first steps in R](/tutorial/first-steps/).]\n`bit64`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz <- bit64::as.integer64(2147483648)\nbit64::is.integer64(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n\n> Because this is a data type that has been added to `R` later, several functions\ndo not work with 64-bit integers if the package `bit64` is not installed. \nMoreover, several standard functions return very irritating outputs:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n:::\n\n\n\n> For this reason, and because `bit64` is not part of the standard installation\nof `R`, you should avoid storing large numbers as `integer64` whenever possible.\nVery large numbers should be stored as `double` or, when precision is a serious\nissue, you should scale them down and then save them as `integer`.\n\n### Logical operations\n\nThe logical values `TRUE` and `FALSE` are often the result of logical \noperations, such as 'Is 2 larger than 1?'.\nSuch logical operations occur very frequently and its a good idea to familiarize\nyourself with the logical operators. You can find an overview in the following\ntable:\n\n| Operator | Function in R | Example  |\n|:--------:|:-------------:|:---------|\n| larger | `>` | `2>1` |\n| smaller | `<` | `2<4` |\n| equal   | `==` | `4==3` |\n| larger or equal | `>=` | `8>=8` |\n| smaller or equal | `<=` | `5<=9` |\n| not equal | `!=` | `4!=5` |\n| and | `&` | `x<90 & x>55` |\n| or | `|` | `x<90 | x>55` |\n| either or | `xor()` | `xor(2<1, 2>1)` |\n| not | `!` | `!(x==2)` |\n| is true | `isTRUE()` | `isTRUE(1>2)` |\n\nThe result of such logical operations is always a logical value:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 4\ny <- x == 8\ntypeof(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"logical\"\n```\n:::\n:::\n\n\n\nYou may also test longer vectors:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:3\nx<2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE FALSE\n```\n:::\n:::\n\n\n\nTests can also be chained:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1L\nx>2 | x<2 & (is.double(x) & x!=0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\n\nSince many mathematical operations interpret `TRUE` as `1`, it is easy to \ncheck how often a certain condition is met:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:50 \nsmaller_20 <- x<20 \nprint(\n  sum(smaller_20) # How many elements are smaller then 20?\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 19\n```\n:::\n\n```{.r .cell-code}\nprint(\n  sum(smaller_20/length(x)) # Whats the share of these elements?\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.38\n```\n:::\n:::\n\n\n\n### Vectorization\n\nThe chained operation we just saw is an example for *vectorizing* an operation.\nThis means that the same operation is applied to many elements, all of which\nare concatenated as a vector. For instance, if you want to compute the\nsquare root of the numbers 5, 6 and 7 you could do:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.236068\n```\n:::\n\n```{.r .cell-code}\nsqrt(6)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.44949\n```\n:::\n\n```{.r .cell-code}\nsqrt(7)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.645751\n```\n:::\n:::\n\n\n\nOr you vectorize the operation:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt(c(5,6,7))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.236068 2.449490 2.645751\n```\n:::\n:::\n\n\n\nVectorizing operations is very useful since it speeds up the computations \nconsiderably. Vectorized operations are *far* more efficient and faster\nthan applying the operation to each element of the vector separately. Thus,\nwhenever you need to apply a certain operation more than once you should always\nthink about using vectorization.^[We learn more about this later in the course\nwhen delving into the topic of *iteration*.]\n\n### More on words\n\nWords are distinguished by the fact that their beginning and their end gets \nindicated by the symbol `'` or `\"`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- \"Hello\"\ntypeof(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- 'Bye!'\ntypeof(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n:::\n\n\n\nJust as other kinds of atomic vectors, they can by concatenated using `c()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz <- c(x, \"und\", y)\nz\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Hello\" \"und\"   \"Bye!\" \n```\n:::\n:::\n\n\n\nA useful function in this context is `paste()`, which transforms and combines\nelements of several vectors: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:10\ny <- paste(\"Try nb.\", x)\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"Try nb. 1\"  \"Try nb. 2\"  \"Try nb. 3\"  \"Try nb. 4\"  \"Try nb. 5\" \n [6] \"Try nb. 6\"  \"Try nb. 7\"  \"Try nb. 8\"  \"Try nb. 9\"  \"Try nb. 10\"\n```\n:::\n:::\n\n\n\nThe function `paste()` also accepts an optional argument `sep`, which allows\nus to specify a token that should be placed between the elements to be \ncombined (the default is `sep=\" \"`): \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nday_nr <- 1:10\nx_axis <- paste(\"Day\", day_nr, sep = \": \")\nx_axis\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"Day: 1\"  \"Day: 2\"  \"Day: 3\"  \"Day: 4\"  \"Day: 5\"  \"Day: 6\"  \"Day: 7\" \n [8] \"Day: 8\"  \"Day: 9\"  \"Day: 10\"\n```\n:::\n:::\n\n\n\n\n> *Note**: Here we have an example of what is called 'recycling'. \nsince the vector `c(\"Day\")` was shorter than the vector `day_nr`, `c(\"Day\")` \nis simply copied so that the operation with `paste()` makes sense.\nRecycling is useful, but sometimes it can be harmful, namely when you think \nthat you are using two vectors of the same length, but this is actually not\nthe case. In such a case recycling leads to the fact that \nno error message is printed and the fact that the two vectors are not of the\nsame length remains unnoticed An example of this is the following code, in which\nthe intention is clearly to connect all weekdays to numbers and one weekday was\nsimply forgotten:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndays <- paste(\"Tag \", 1:7, \":\", sep=\"\")\nday_names <- c(\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\")\npaste(days, day_names)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Tag 1: Monday\"    \"Tag 2: Tuesday\"   \"Tag 3: Wednesday\" \"Tag 4: Thursday\" \n[5] \"Tag 5: Friday\"    \"Tag 6: Saturday\"  \"Tag 7: Monday\"   \n```\n:::\n:::\n\n\n\n### Missing values and NULL\n\nAs indicated above, missing values are encoded as `NA`. This is particularly \nuseful in statistical contexts, where are particular element of a vector cannot\nsimply be removed if it is unavailable.\n\n> **Example:** The vector `x` contains a logical value that indicates whether a\nperson has correctly answered the question on a questionnaire. If the person\ndid not answer the third question on the questionnaire, this should be indicated \nby `NA`. Simply omitting the value makes it impossible to determine afterwards \n*which* question the person did not answer.\n\nMost operations that get `NA` as an input will also give `NA` as an output, \nbecause it is unclear what the result of the operation would be for different \nvalues for for the missing value:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n5 + NA\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n\n\nThe only exception is an operation that yields a certain value completely \nindependent from what you would substitute for `NA`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nNA | TRUE # Always TRUE, no matter what you substitute for NA\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n\nTo test whether a vector `x` contains missing values you should always use the \nfunction `is.na`, never `x==NA`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(NA, 5, NA, 10)\nprint(x == NA) # Unclear since not clear whether all NA must stand for the same value\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA NA NA NA\n```\n:::\n\n```{.r .cell-code}\nprint(\n  is.na(x)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE  TRUE FALSE\n```\n:::\n:::\n\n\n\nWhenever an operation yields a value that cannot be defined, the result is\nnot `NA` but `NaN` (*not a number*):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n0 / 0\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NaN\n```\n:::\n:::\n\n\n\nAnother special element is `NULL`. \n`NULL` is in fact a data type in itself (i.e. it is not a vector), \nbut in practice its best thought of as a vector of length zero:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- NULL\nlength(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n:::\n\n\n\n`NULL` is frequently used to indicate that something does not exist.\nAn empty vector, for instance, is `NULL`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c()\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n\n```{.r .cell-code}\nlength(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n:::\n\n\n\nThis is different to a vector with one (or more) missing *elements*:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- NA\nlength(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n\n\nWhen you define your own functions, you might use `NULL` as the default value\nfor optional arguments. We will learn about such more advanced strategies \nlater in this course. For now, its best to think of `NULL` as an vector \nof length zero. \n\n### Indexing and replacement\n\nWe can extract single elements of a vector using squared brackets:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(2,4,6)\nx[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n:::\n\n\n\nThis also allows us to modify specific elements:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(2,4,6)\nx[2] <- 99\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  2 99  6\n```\n:::\n:::\n\n\n\nBut we can also extract more than one element:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[1:2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  2 99\n```\n:::\n:::\n\n\n\nNegative indices eliminate the respective elements:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[-1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 99  6\n```\n:::\n:::\n\n\n\nTo get the last element of a vector you might combine this idea with the \nfunction `length()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[length(x)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6\n```\n:::\n:::\n\n\n\n\n### Useful functions when working with atomic vectors\n\nHere we shall mention a few functions that are particularly useful in the context of \natomic vectors,^[For many common tasks there is already a predefined function in\nR. The easiest way to find them is by googling] \nespecially when it comes to producing such vectors \nor to perform arithmetic operations with them.\n\n**Creating atomic vectors**:\n\nA sequence of whole numbers is something that we use very frequently.\nTo create such sequences, the shortcut `:` comes in handy:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:10\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- 10:1\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 10  9  8  7  6  5  4  3  2  1\n```\n:::\n:::\n\n\n\nTo build more complex sequences we can use `seq()`, which in its simplest \ncase is equivalent to `:`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- seq(1, 10)\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n:::\n:::\n\n\n\nThe function `seq()`, however, allows for a number of useful optional arguments.\nFor instance, `by` allows us to control the space between the numbers: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- seq(1, 10, by = 0.5)\nprint(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  1.0  1.5  2.0  2.5  3.0  3.5  4.0  4.5  5.0  5.5  6.0  6.5  7.0  7.5  8.0\n[16]  8.5  9.0  9.5 10.0\n```\n:::\n:::\n\n\n\nIf we want to specify the desired length of the resulting vector and let \n`R` choose the necessary space between the elements, we may use `length.out`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz <- seq(2, 8, length.out = 4)\nprint(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 4 6 8\n```\n:::\n:::\n\n\n\nAnd if we want to create a vector with the length as another vector,\nthe argument `along.with` comes in handy. This is often used for creating\nindex vectors.^[An index vector `x` to any vector\n`y` with `N` elements contains the integers from 1 to `N`. The *n*th value\nof x thus corresponds to the index of the *n*th value of `y`.]\nIn such a case we do not have to specify the index numbers\ndirectly:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz_index <- seq(along.with = z)\nprint(z_index)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4\n```\n:::\n:::\n\n\n\nAnother common task is to repeat a certain vector. This can be done with `rep()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- rep(NA, 5)\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA NA NA NA NA\n```\n:::\n:::\n\n\n\n\n**Operations**\n\nThere are a number of operations that we use very frequently together with vectors.\nOften we are interested in the **length** of a vector. \nFor this we can use the function `length()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1,2,3,4)\nlength(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n:::\n\n\n\nIf we are looking for the **largest** and **smallest** value of a vector we can\nuse `min()` and `max()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmin(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmax(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n:::\n\n\n\nBoth functions (and many more similar functions) have the optional argument\n`na.rm`, which can be either `TRUE` or `FALSE`. \nIn the case of `TRUE`, all `NA` values are removed before the operation\ngets applied: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- c(1,2,3,4,NA)\nmin(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmin(y, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n\n\n\nThe **mean** or the **variance/standard deviation** of the elements can be \ncomputed with `mean()`, `var()`, and `sd()`, all of which have also the\noptional argument`na.rm`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.5\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nvar(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nvar(y, na.rm = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.666667\n```\n:::\n:::\n\n\n\nFinally, we often want to compute the **sum** or the **product** of all \nthe elements of the vector. Here the functions `sum()` and `prod()` are useful:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprod(y, na.rm = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 24\n```\n:::\n:::\n\n\n\n\n## Lists\n\nIn contrast to atomic vectors, lists can contain objects of different types.\nWe create lists via the function `list()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nl_1 <- list(\n  \"a\",\n  c(1,2,3),\n  FALSE\n)\ntypeof(l_1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"list\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nl_1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] \"a\"\n\n[[2]]\n[1] 1 2 3\n\n[[3]]\n[1] FALSE\n```\n:::\n:::\n\n\n\nLists can become very complex. The function `str()` (short for \"structure\") \nhelps us to get a quick overview over a list and its elements:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(l_1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 3\n $ : chr \"a\"\n $ : num [1:3] 1 2 3\n $ : logi FALSE\n```\n:::\n:::\n\n\n\nWe can name the elements of lists:^[We can actually also do this with \nvectors, but it is more common in the context of lists.]\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nl_2 <- list(\n  \"first_element\" = \"a\",\n  \"second_element\" = c(1,2,3),\n  \"third_element\" = FALSE\n)\n```\n:::\n\n\n\nWe can retrieve the names of all elements of the list with `names()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(l_2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"first_element\"  \"second_element\" \"third_element\" \n```\n:::\n:::\n\n\n\nThere are two very important differences in the handling of vectors and lists:\n\n1. Vectorization does not work for lists\n2. Indexing works differently\n\nThe first issue can be illustrated easily:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec_expl <- c(1,2,3)\nlist_expl <- list(1,2,3)\nsqrt(vec_expl)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.000000 1.414214 1.732051\n```\n:::\n:::\n\n\n\nBut:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt(list_expl)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in sqrt(list_expl): non-numeric argument to mathematical function\n```\n:::\n:::\n\n\n\nThe second issue is due to the more complex structure of lists. For vectors we\nextracted single elements via `[`. For lists, there is a difference between\n`[` and `[[`. The former always returns a list:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nl_1[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1 2 3\n```\n:::\n:::\n\n\n\nThe second then returns a vector and is more similar to the behavior of `[` in\nthe context of atomic vectors:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nl_1[[2]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n:::\n\n\n\nTo extract an element of this vector we can chain the brackets:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nl_1[[2]][3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n\n\nWe can also extract elements by their name:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nl_2[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nl_2[[\"first_element\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\"\n```\n:::\n:::\n\n\n\nLists are fundamental to many more complex structures that we will encounter \nlater. They are more flexible than atomic vectors, but this flexibility also\nmakes them more difficult to use and less efficient for tasks where this \nflexibility is not needed. As a rule of thumb, whenever you can represent \nsomething as an atomic vector, you should do so. You should always have a good\nreason for using lists!\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}