{
  "hash": "7880ecf4d72bb18cb087a5e024c65a34",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Data preparation # Also check out line 43\nauthor: Claudius Gräbner-Radkowitsch\ndate: '2025-05-23'\nexecute: \n  freeze: auto\nformat: \n  html:\n    theme: readable\n    highlight: tango\n    toc: true\n    toc_depth: 2\n    number_sections: true # Skip pdf\n  pdf:\n    papersize: a4\n    toc: true\n    toc-depth: 2\n    number-sections: true\n    include-in-header: \n      text: |\n        \\usepackage{lmodern} \n        \\usepackage{graphicx}\n        \\usepackage{hyperref}\n        \\usepackage{url}                \n        \\usepackage{xcolor}\n        \\usepackage{booktabs}\n        \\usepackage{listings}\n        \\lstloadlanguages{R}\n        \n        \\definecolor{eufblue}{RGB}{0,57,91}\n        \\definecolor{eufgrey}{RGB}{111,111,111}\n        \\definecolor{euflightblue}{RGB}{105,170,205}\n        \n        \\hypersetup{\n        pdfauthor={Claudius Graebner-Radkowitsch}\n        colorlinks=true,\n        linkcolor=euflightblue,\n        urlcolor=euflightblue\n        }\n        \\usepackage[includehead,includefoot,top=2cm, bottom=1.5cm]{geometry}\n        \\usepackage[headsepline, footsepline]{scrlayer-scrpage}\n        \\pagestyle{scrheadings}\n        \\clearpairofpagestyles\n        \\ihead{Tutorial: First steps in R}\n        %\\chead{Kopfzeile Mitte}\n        \\ohead{\\pagemark} %\n        \\ifoot{}\n        \\cfoot{\\href{https://euf-datascience-spring24.netlify.app/}{\\normalfont\\color{eufblue}{Data Science Using R - Spring Semester 2024}}} % Fußzeile Mitte\n        \\ofoot{} \n        \\setkomafont{disposition}{\\color{eufblue}\\bfseries}\n---\n\n\n# Packages and data used\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(data.table)\nlibrary(here)\n```\n:::\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe data sets used in these notes are available from the \n[course homepage](data-examples.zip):\n\n* `wrangling_data_raw.csv` (`data_raw`)\n* `wrangling_data_raw_long.csv` (`data_raw_long`)\n* `wrangling_data_final_expl.csv` (`data_final_expl`)\n* `wrangling_gini_join.csv` (`gini_join`)\n* `wrangling_gdp_join.csv` (`gdp_join`)\n\nThe brackets show the names of the data sets used below.\n\n# General remarks\n\n* If you imported the data from a file, make sure that the import went as expected\n* Start with a data set that is of the type `tibble` (use `tibble::as_tibble()` if necessary)\n* Before starting to wrangle, make a note to yourself of how the final data set should look like; \n  * Then think about the different steps you need to take to reach this goal;\n  * Each step should only address one single wrangling challenge\n* It is often useful to save the wrangling code in one script in which you \nimport raw data in the beginning and save tidy data in the end; this allows you \nto keep data wrangling, visualization, and modelling in separate files\n\n# Reshaping data with the tidyr package\n\nAt the end of each data wrangling activity, you should have created \n[tidy data](https://cran.r-project.org/web/packages/tidyr/vignettes/tidy-data.html). \nThe R package that contains functions meant to assist you in \nthis process is called [tidyr](https://tidyr.tidyverse.org/).\nWhile it contains functions for various purposes, the by far most common\n(and, to be honest, to most demanding) task is to reshape data from long to \nwide format and vice versa. This will be the focus of this section. \nTutorials on the other `tidyr`-functions can be found on the official package\ndocumentation, but these functions are more specific and not as important\nin daily practice as those for reshaping data.\n\n## Wide and long format: definition\n\nThere is no strict definition for wide and long data. Rather, the two \nshould be understood as *relative* descriptions of data, meaning that it is\nmore straightforward to speak of a data set that is long*er* relative to\nanother one, rather than *a long* data set per se.\n\nHere is an example for a rather long data set:\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n   country  year variable    value\n    <char> <int>   <char>    <num>\n1: Germany  2017    unemp     3.75\n2: Germany  2017      gdp 53071.46\n3: Germany  2018    unemp     3.38\n4: Germany  2018      gdp 53431.39\n5:  Greece  2017    unemp    21.49\n6:  Greece  2017      gdp 28604.86\n7:  Greece  2018    unemp    19.29\n8:  Greece  2018      gdp 29141.17\n```\n\n\n:::\n:::\n\n\nHere, we have one column identifying the variable, the value of which is \nstored in a separate column.\nThis means that the data is relatively 'long' in the sense of having\nmany rows. At the same time, it is relatively 'narrow' in the sense of not\nhaving too many columns since the variable identifier is kept in a single \ncolumn.\n\nContrast this with an example for a rather wide data set, where each variable\nhas its own column:\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n   country  year unemp      gdp\n    <char> <int> <num>    <num>\n1: Germany  2017  3.75 53071.46\n2: Germany  2018  3.38 53431.39\n3:  Greece  2017 21.49 28604.86\n4:  Greece  2018 19.29 29141.17\n```\n\n\n:::\n:::\n\n\nWhile the number of columns remains the same, the data set has relatively more\ncolumns as compared to the rows. At the same time, it tends to be shorter in\nthe sense of having fewer rows.^[If we had a data set with three instead of\ntwo variables, the wide data set would have the same number of rows, but \nmore columns, i.e. it would be wider in an absolute sense as well.]\n\nWhile the long format is often easier to read and preferable when communicating\ndata to humans, making data tidy often involves the task of making data \n'longer'.\n\n## Transforming long data into wide data\n\nTo make data wider we use the function `tidyr::pivor_wider()`.\n\nAssume that we start with our long data set introduced above and that this\ndata set is bound to the name `data_raw_long`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::glimpse(data_raw_long)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 8\nColumns: 4\n$ country  <chr> \"Germany\", \"Germany\", \"Germany\", \"Germany\", \"Greece\", \"Greece…\n$ year     <int> 2017, 2017, 2018, 2018, 2017, 2017, 2018, 2018\n$ variable <chr> \"unemp\", \"gdp\", \"unemp\", \"gdp\", \"unemp\", \"gdp\", \"unemp\", \"gdp\"\n$ value    <dbl> 3.75, 53071.46, 3.38, 53431.39, 21.49, 28604.86, 19.29, 29141…\n```\n\n\n:::\n:::\n\n\nWe will now use `tidyr::pivor_wider()` to make this data set wider. The most\nimportant arguments of this function are as follows:^[\n  The function allows for much more finetuning. \n  You might read more about its argument in the help page of the function or the \n  [online documentation](https://tidyr.tidyverse.org/reference/pivot_wider.html).]\n\n* `data` is the first argument and refers to the name of the data set to be considered\n* `names_from` denotes the column that includes the names of the new columns\n* `values_from` denotes the column that includes the values to be allocated in the newly created cells\n\nIn the present case, the call would look like the following:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_raw_wide <- tidyr::pivot_wider(\n  data = data_raw_long, \n  names_from = \"variable\", \n  values_from = \"value\")\ndata_raw_wide\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 4\n  country  year unemp    gdp\n  <chr>   <int> <dbl>  <dbl>\n1 Germany  2017  3.75 53071.\n2 Germany  2018  3.38 53431.\n3 Greece   2017 21.5  28605.\n4 Greece   2018 19.3  29141.\n```\n\n\n:::\n:::\n\n\n## Transforming wide data into long data\n\nAssume we want to take the data set `data_raw_wide` and re-create the original\nlong version. To achieve this we can use `tidyr::pivot_longer()`. Again, lets\nhave a look at the most important arguments:^[\n  See the [online documentation](https://tidyr.tidyverse.org/reference/pivot_longer.html) \n  for a more complete description.]\n  \n* `data` is the first argument and refers to the name of the data set to be considered\n* `cols` denotes the columns that should be transformed into the longer format\n* `names_to` denotes the column that includes the names of the new columns\n* `values_to` denotes the column that includes the values to be allocated in the newly created cells\n\nThe arguments `names_to` and `values_to` are not strictly necessary since they\nhave useful default values, but its usually nicer to be explicit.\n\nWhen specifying the argument `cols` you have several possibilities. The \nsimplest variant is to pass a character vector with the column names. \nBut note that you can save a lot of writing by using so called\n[selection helpers](https://dplyr.tidyverse.org/reference/dplyr_tidy_select.html), \na very useful tool we will learn about later.\n\nIn our case this amounts to:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_raw_long <- tidyr::pivot_longer(\n  data = data_raw_wide, \n  cols = c(\"unemp\", \"gdp\"), \n  names_to = \"indicator\", \n  values_to = \"values\")\ndata_raw_long\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 8 × 4\n  country  year indicator   values\n  <chr>   <int> <chr>        <dbl>\n1 Germany  2017 unemp         3.75\n2 Germany  2017 gdp       53071.  \n3 Germany  2018 unemp         3.38\n4 Germany  2018 gdp       53431.  \n5 Greece   2017 unemp        21.5 \n6 Greece   2017 gdp       28605.  \n7 Greece   2018 unemp        19.3 \n8 Greece   2018 gdp       29141.  \n```\n\n\n:::\n:::\n\n\n\n# Chaining wrangling tasks using pipes\n\nPipes are provided via the package `magrittr`, which is loaded automatically if\nyou attach packages such as `tidyr` or `dplyr`. Pipes are short keywords that\nfacilitate the development of very readable and transparent data wrangling code.\n\nWhile there are many \n[different pipes](https://magrittr.tidyverse.org/reference/index.html), \nthe one we will use extensively is `%>%`.\nIt is always used at the end of a line, and it basically 'throws' the result\nof this line into the next line of code. In this line, you can refer to the \nintermediate result via `.`, or it is used implicitly as the first argument\nto the function you use.\n\nIn other words, `x %>% f(y)` (or `x %>% f(., y)`) is equivalent to `f(x, y)`.\n\nBut lets look at an example! Assume we start with the following data set:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npipe_data_raw <- data_raw %>%\n  select(country, year, gdp, unemp)\npipe_data_raw\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   country  year      gdp unemp\n    <char> <int>    <num> <num>\n1: Germany  2017 53071.46  3.75\n2: Germany  2018 53431.39  3.38\n3:  Greece  2017 28604.86 21.49\n4:  Greece  2018 29141.17 19.29\n```\n\n\n:::\n:::\n\n\nAnd what we want is this:\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 4\n  country name    `2017`   `2018`\n  <chr>   <chr>    <dbl>    <dbl>\n1 Germany gdp   53071.   53431.  \n2 Germany unemp     3.75     3.38\n3 Greece  gdp   28605.   29141.  \n4 Greece  unemp    21.5     19.3 \n```\n\n\n:::\n:::\n\n\nWe can do this by first making the data longer, and then wider. We could do \nthis explicitly:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npipe_data_1 <- pivot_longer(\n  data = pipe_data_raw, \n  cols = all_of(c(\"gdp\", \"unemp\")))\n\npipe_data_2 <- pivot_wider(\n  data = pipe_data_1,\n  names_from = \"year\", \n  values_from = \"value\") \n```\n:::\n\n\n\nBut we can also write this code more concisely using the pipe:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npipe_data_final <- pivot_longer(\n  data = pipe_data_raw, \n  cols = all_of(c(\"gdp\", \"unemp\"))) %>%\n  pivot_wider(\n  data = .,\n  names_from = \"year\", \n  values_from = \"value\") \n```\n:::\n\n\n\nOr, since the pipe carries the intermediate result implicitly as the first\nargument to the function on the next line we can space the `data = .`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npipe_data_final <- pivot_longer(\n  data = pipe_data_raw, \n  cols = all_of(c(\"gdp\", \"unemp\"))) %>%\n  pivot_wider(\n  names_from = \"year\", \n  values_from = \"value\") \n```\n:::\n\n\nThe `%>%`-pipe allows you to write very readable code, so make sure you use it\noften. But for code development it might be nevertheless helpful to write the\nintermediate steps explicitly.\n\n# Manipulating data with the dplyr package\n\nThe package `tidyr` is for turning messy data sets into tidy data sets. \nAnother important part of data preparation is to manipulate an existing data\nset. To do this, the package [dplyr](https://dplyr.tidyverse.org/) contains \nmany useful functions. You will regularly use functions from both the `tidyr` and\n`dplyr` package within your script for data preparation: often, you start with\na messy data set, make it tidy using functions from `tidyr` and then use\nfunctions from `dplyr` to manipulate variables until your data set contains all \nthe information you want. Thus, in the following we cover the most frequently\nused `dplyr`-functions. A complete documentation of the whole package can be\nfound on the official [dplyr webpage](https://dplyr.tidyverse.org/).\n\n## Creating or manipulating variables\n\nThe function `dplyr::mutate()` is used both for manipulating existing \ncolumns as well as creating new columns. In the first case the name of the \ncolumn that the result of `dplyr::mutate()` is written into already exists,\nin the second case we just use a new name.\n\nConsider the following data set with the unemployment rate as an example:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_unemp\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 3\n   year Germany Greece\n  <int>   <dbl>  <dbl>\n1  2017    3.75   21.5\n2  2018    3.38   19.3\n```\n\n\n:::\n:::\n\nAssume we want to express the percentage values via decimal numbers and, to\nthis end, divide the values in the columns `Germany` and `Greece` by 100. We\ncan use `dplyr::mutate()` to achieve this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_unemp %>%\n  dplyr::mutate(\n    Germany = Germany/100,\n    Greece = Greece/100\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 3\n   year Germany Greece\n  <int>   <dbl>  <dbl>\n1  2017  0.0375  0.215\n2  2018  0.0338  0.193\n```\n\n\n:::\n:::\n\n\nBut we could use basically the same code to create a new column. Assume, for\ninstance, we want a new column containing the difference between the \nunemployment rates:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_unemp %>%\n  dplyr::mutate(\n    Difference = Greece - Germany\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 4\n   year Germany Greece Difference\n  <int>   <dbl>  <dbl>      <dbl>\n1  2017    3.75   21.5       17.7\n2  2018    3.38   19.3       15.9\n```\n\n\n:::\n:::\n\n\nThe only difference here was that the left-hand-side name of the column to \nbe manipulated did not exist before!\n\n## Filtering rows\n\nThe function `dplyr::filter()` can be used to filter rows according to \ncertain conditions. The conditions must evaluate for each cell entry to \neither `TRUE` or `FALSE`, and only those rows for which they evaluate to `TRUE`\nremain in the data set. Often, the conditions are specified via \nlogical operators, which were already covered in the tutorial on \n[vector types](/tutorial/object-types-vec/).\n\nAs always, the first argument to `dplyr::filter()` is `data`, i.e. the data\nset on which you want to operate. Then follow an arbitrary number of logical\nconditions on the different columns of the data set on question. \n\nAssume we want to take the previously defined data set `data_raw_long`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_raw_long\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 8 × 4\n  country  year indicator   values\n  <chr>   <int> <chr>        <dbl>\n1 Germany  2017 unemp         3.75\n2 Germany  2017 gdp       53071.  \n3 Germany  2018 unemp         3.38\n4 Germany  2018 gdp       53431.  \n5 Greece   2017 unemp        21.5 \n6 Greece   2017 gdp       28605.  \n7 Greece   2018 unemp        19.3 \n8 Greece   2018 gdp       29141.  \n```\n\n\n:::\n:::\n\n\nand only want to keep data on GDP:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_raw_long %>%\n  dplyr::filter(indicator==\"gdp\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 4\n  country  year indicator values\n  <chr>   <int> <chr>      <dbl>\n1 Germany  2017 gdp       53071.\n2 Germany  2018 gdp       53431.\n3 Greece   2017 gdp       28605.\n4 Greece   2018 gdp       29141.\n```\n\n\n:::\n:::\n\n\nYou may also combine more than one condition in one call to `dplyr::filter()`.\nIf you also want to filter by values and only keep those rows where the value\nis below 50.000:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_raw_long %>%\n  dplyr::filter(\n    indicator==\"gdp\",\n    values < 50000)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 4\n  country  year indicator values\n  <chr>   <int> <chr>      <dbl>\n1 Greece   2017 gdp       28605.\n2 Greece   2018 gdp       29141.\n```\n\n\n:::\n:::\n\n\n## Selecting columns \n\nWhen you only want to keep certain *columns* we speak of selecting (rather than\nfiltering) columns. This is done - surprise - via the function ´dplyr::select()`.\n\nThere are different ways for selecting columns. In any case, the first argument\nis, again, `data`, i.e. the data set considered. In the present case, we will\nrefer to `data_raw`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_raw\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   country  year unemp      gdp\n    <char> <int> <num>    <num>\n1: Germany  2017  3.75 53071.46\n2: Germany  2018  3.38 53431.39\n3:  Greece  2017 21.49 28604.86\n4:  Greece  2018 19.29 29141.17\n```\n\n\n:::\n:::\n\n\nThen we can now select columns using one of the following two options.\nFirst, you may refer to columns via their *name*:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_raw %>%\n  dplyr::select(country, year, unemp)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   country  year unemp\n    <char> <int> <num>\n1: Germany  2017  3.75\n2: Germany  2018  3.38\n3:  Greece  2017 21.49\n4:  Greece  2018 19.29\n```\n\n\n:::\n:::\n\n\nBut this is often error-prone. Thus, it is usually better to refer to the columns via \n[selection helpers](https://dplyr.tidyverse.org/reference/dplyr_tidy_select.html),\nwhich is also the most flexible version. While we will learn about more selection \nhelpers later, here we will mainly use `dplyr::all_of()`, which accepts a character\nvector of column names:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_raw %>%\n  dplyr::select(dplyr::all_of(c(\"country\", \"year\", \"gdp\")))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   country  year      gdp\n    <char> <int>    <num>\n1: Germany  2017 53071.46\n2: Germany  2018 53431.39\n3:  Greece  2017 28604.86\n4:  Greece  2018 29141.17\n```\n\n\n:::\n:::\n\n\n> **Caution:** Do not forget the `c()`! Otherwise:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_raw %>%\n  dplyr::select(dplyr::all_of(\"country\", \"year\", \"gdp\"))\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `dplyr::select()`:\nℹ In argument: `dplyr::all_of(\"country\", \"year\", \"gdp\")`.\nCaused by error in `dplyr::all_of()`:\n! unused arguments (\"year\", \"gdp\")\n```\n\n\n:::\n:::\n\n\n> It is also possible to define the column vector first:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncols2keep <- c(\"country\", \"year\", \"gdp\")\ndata_raw %>%\n  dplyr::select(dplyr::all_of(cols2keep))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   country  year      gdp\n    <char> <int>    <num>\n1: Germany  2017 53071.46\n2: Germany  2018 53431.39\n3:  Greece  2017 28604.86\n4:  Greece  2018 29141.17\n```\n\n\n:::\n:::\n\n\n> Selection helpers allow you to specify the columns to be selected more\ngenerally. For instance, `dplyr::ends_with()` allows you to select all colums\nthat end with a certain pattern:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_raw %>%\n  dplyr::select(dplyr::ends_with(\"p\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   unemp      gdp\n   <num>    <num>\n1:  3.75 53071.46\n2:  3.38 53431.39\n3: 21.49 28604.86\n4: 19.29 29141.17\n```\n\n\n:::\n:::\n\n\nIn any case, you can also specify the columns you want to *drop*. To this end, \njust add a `-` in front of the selection command:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_raw %>%\n  dplyr::select(-unemp, -gdp)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   country  year\n    <char> <int>\n1: Germany  2017\n2: Germany  2018\n3:  Greece  2017\n4:  Greece  2018\n```\n\n\n:::\n:::\n\n\n## Merging data sets\n\nOften you need to obtain data from different sources. To merge all your data\nin one single data set, you need to use one of the `*_join()` functions of the\n`dplyr`-package. These functions all merge two data sets, but the way they do\nit is different. Below we illustrate the most common joins (so called \n[mutating joins](https://dplyr.tidyverse.org/reference/mutate-joins.html)).^[\n  The other join types are \n  [filtering joins](https://dplyr.tidyverse.org/reference/filter-joins.html) and \n  [nest joins](https://dplyr.tidyverse.org/reference/nest_join.html). You find \n  more information in the web, and more details on the underlying theory in \n  [chapter 13 of R4DS](https://r4ds.had.co.nz/relational-data.html).]\n\nAs a guiding example we use the following two data sets:\n\nFirst, data on income inequality from the \n[SWIID data base](https://fsolt.org/swiid/):\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngini_join\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   country  year  gini\n    <char> <int> <num>\n1:  Greece  2015  33.1\n2:  Greece  2017  32.2\n```\n\n\n:::\n:::\n\n\nSecond, data on GDP per capita from the \n[World Bank](https://data.worldbank.org/indicator/NY.GDP.PCAP.PP.KD):\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngdp_join\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   country  year      gdp\n    <char> <int>    <num>\n1: Germany  2017 53071.46\n2: Germany  2018 53431.39\n3:  Greece  2017 28604.86\n4:  Greece  2018 29141.17\n```\n\n\n:::\n:::\n\n\nWe will consider the behavior of the following four functions:\n\n* `dplyr::left_join()`\n* `dplyr::right_join()`\n* `dplyr::full_join()`\n* `dplyr::inner_join()`\n\nAll of them accept the following arguments:\n\n* `x` and `y`: the two data sets to be merged\n* `by`: a vector or a named vector indicating on which columns the data sets \nshould be merged\n\nIts easier to understand their behavior if you contrast them directly with\neach other. First, `dplyr::left_join()` joins the data sets on those \ncolumns mentioned in `by`, but only keeps those rows for which `x` contains\nan observation:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::left_join(x = gdp_join, y = gini_join, by = c(\"country\", \"year\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   country  year      gdp  gini\n    <char> <int>    <num> <num>\n1: Germany  2017 53071.46    NA\n2: Germany  2018 53431.39    NA\n3:  Greece  2017 28604.86  32.2\n4:  Greece  2018 29141.17    NA\n```\n\n\n:::\n:::\n\n\nThis might introduce `NA`s into the columns of `y`, but not of `x`. It is the\nother way around for `dplyr::right_join()`: it only keeps those rows for \nwhich `y` contains an observation:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::right_join(x = gdp_join, y = gini_join, by = c(\"country\", \"year\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   country  year      gdp  gini\n    <char> <int>    <num> <num>\n1:  Greece  2017 28604.86  32.2\n2:  Greece  2015       NA  33.1\n```\n\n\n:::\n:::\n\n\n`dplyr::inner_join()` is the most restrictive option, keeping only those rows\nfor which both `x` and `y` contain an observation (i.e. it never introduces\n`NA`s):\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::inner_join(x = gdp_join, y = gini_join, by = c(\"country\", \"year\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   country  year      gdp  gini\n    <char> <int>    <num> <num>\n1:  Greece  2017 28604.86  32.2\n```\n\n\n:::\n:::\n\n\nFinally, `dplyr::full_join()` contains all rows that occur at least in `x` *or*\n`y`, i.e. it might introduce `NA`s in both the columns of `x` and `y`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::full_join(x = gdp_join, y = gini_join, by = c(\"country\", \"year\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   country  year      gdp  gini\n    <char> <int>    <num> <num>\n1: Germany  2017 53071.46    NA\n2: Germany  2018 53431.39    NA\n3:  Greece  2017 28604.86  32.2\n4:  Greece  2018 29141.17    NA\n5:  Greece  2015       NA  33.1\n```\n\n\n:::\n:::\n\n\n\nTwo final remarks: first, the types of the columns on which you merge the \ndata sets must be equal, otherwise R throws an error:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngini_join <- dplyr::mutate(gini_join, year=as.character(year))\ndplyr::left_join(x = gdp_join, y = gini_join, by = c(\"country\", \"year\"))\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `dplyr::left_join()`:\n! Can't join `x$year` with `y$year` due to incompatible types.\nℹ `x$year` is a <integer>.\nℹ `y$year` is a <character>.\n```\n\n\n:::\n:::\n\n\nJust enforce the correct data type before merging:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngini_join %>% \n  dplyr::mutate(year=as.integer(year)) %>%\n  dplyr::left_join(x = gdp_join, y = ., by = c(\"country\", \"year\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   country  year      gdp  gini\n    <char> <int>    <num> <num>\n1: Germany  2017 53071.46    NA\n2: Germany  2018 53431.39    NA\n3:  Greece  2017 28604.86  32.2\n4:  Greece  2018 29141.17    NA\n```\n\n\n:::\n:::\n\n\nSecond, you can also merge on columns with different names by passing named\nvectors to `by`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngini_join <- gini_join %>%\n  mutate(Year=as.double(year)) %>%\n  select(-year)\ngini_join\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   country  gini  Year\n    <char> <num> <num>\n1:  Greece  33.1  2015\n2:  Greece  32.2  2017\n```\n\n\n:::\n:::\n\n\nThen this does not work any more:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::left_join(\n  x = gdp_join, y = gini_join, \n  by = c(\"country\", \"year\"))\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `dplyr::left_join()`:\n! Join columns in `y` must be present in the data.\n✖ Problem with `year`.\n```\n\n\n:::\n:::\n\n\nBut the named vector fixes it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::left_join(\n  x = gdp_join, y = gini_join, \n  by = c(\"country\", \"year\"=\"Year\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   country  year      gdp  gini\n    <char> <num>    <num> <num>\n1: Germany  2017 53071.46    NA\n2: Germany  2018 53431.39    NA\n3:  Greece  2017 28604.86  32.2\n4:  Greece  2018 29141.17    NA\n```\n\n\n:::\n:::\n\n\n## Grouping and summarising data\n\nThe final challenge we consider involves the application of two functions\n(at least in most cases): `dplyr::group_by()` and `dplyr::summarize()`.\n\n`dplyr::group_by()` is usually used within pipes and groups a data set \naccording to an arbitrary number of variables, each of which must refer to \none (and only one) column. It produces a grouped data set:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_raw_grouped <- data_raw %>%\n  dplyr::group_by(country)\ndata_raw_grouped\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 4\n# Groups:   country [2]\n  country  year unemp    gdp\n  <chr>   <int> <dbl>  <dbl>\n1 Germany  2017  3.75 53071.\n2 Germany  2018  3.38 53431.\n3 Greece   2017 21.5  28605.\n4 Greece   2018 19.3  29141.\n```\n\n\n:::\n:::\n\n\nAs you can see, the data set is now grouped by the variable `country`. We can\nspecify the grouping variables the same way we selected columns in the context\nof `dplyr::select()` (see above).\n\nGrouped data sets are usually not interesting in itself. You can ungroup them\nvia `dplyr::ungroup()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_raw_grouped %>%\n  dplyr::ungroup()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 4\n  country  year unemp    gdp\n  <chr>   <int> <dbl>  <dbl>\n1 Germany  2017  3.75 53071.\n2 Germany  2018  3.38 53431.\n3 Greece   2017 21.5  28605.\n4 Greece   2018 19.3  29141.\n```\n\n\n:::\n:::\n\n\nThey are most useful if used in conjunction with `dplyr::summarise()`, which\nsummarizes variables. While it can be used without\n`dplyr::group_by()`, it is most useful if it is applied to grouped data sets:\nthen it computes summary statistics for each group.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_raw %>%\n  summarise(\n    avg_gdp=mean(gdp)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   avg_gdp\n1 41062.22\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_raw_grouped %>%\n  summarise(\n    avg_gdp=mean(gdp)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 2\n  country avg_gdp\n  <chr>     <dbl>\n1 Germany  53251.\n2 Greece   28873.\n```\n\n\n:::\n:::\n\n\nYou can also summarized more than one column:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_raw_grouped %>%\n  summarise(\n    avg_gdp=mean(gdp),\n    median_unemp=median(unemp)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 3\n  country avg_gdp median_unemp\n  <chr>     <dbl>        <dbl>\n1 Germany  53251.         3.57\n2 Greece   28873.        20.4 \n```\n\n\n:::\n:::\n\n\nNote that `dplyr::summarise()` drops all columns that it is not asked to \ncompute summary statistics for, except potential grouping variables. There \nare also some advanced features of the functions, which are explained in\nthe official [documentation](https://dplyr.tidyverse.org/reference/summarise.html).\n\n# A final example\n\nThanks to the pipes it is easy to chain the many different wrangling steps into\none function call. But in practice it is very important that you (1) inspect\nyour raw data very clearly, (2) write down the desired end product, and then (3)\nthink about the single steps required to reach the desired outcome. Each step \nshould address one (and only one) wrangling challenge.\n\nTo illustrate this, assume we start start with this raw data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(data_final_expl)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nClasses 'data.table' and 'data.frame':\t88 obs. of  5 variables:\n $ country: chr  \"Austria\" \"Austria\" \"Austria\" \"Austria\" ...\n $ iso3c  : chr  \"AUT\" \"AUT\" \"AUT\" \"AUT\" ...\n $ year   : int  2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 ...\n $ unemp  : num  4.69 4.01 4.85 4.78 5.83 ...\n $ gdp    : num  46470 46879 47419 47633 48633 ...\n - attr(*, \".internal.selfref\")=<externalptr> \n```\n\n\n:::\n:::\n\n\nWhat we want to do is to compute the difference in the country averages of the \nvariables for the time periods 2005-2007 and 2010-2013. This would look like \nthis:^[We have not yet covered the function `ifelse()`. It contains a logical\ntest as a first argument, and then two further arguments: one return value for\nthe case in which the test returns `TRUE`, and one for which the test returns\n`FALSE`.]\n\n\n\nTo achieve this, we need to chain a number of wrangling challenges introduced \nabove:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_final_expl %>%\n  dplyr::mutate(\n    period = ifelse(\n      test = year %in% 2005:2007, \n      yes = \"Early\", \n      no =  ifelse(\n        test = year %in% 2010:2013, \n        yes = \"Late\", \n        no = NA))\n  ) %>%\n  dplyr::filter(!is.na(period)) %>%\n  group_by(country, period) %>%\n  summarise(\n    avg_unemp = mean(unemp),\n    avg_gdp = mean(gdp), \n    .groups = \"drop\"\n  ) %>%\n  tidyr::pivot_longer(\n    cols = dplyr::all_of(c(\"avg_unemp\", \"avg_gdp\")), \n    names_to = \"indicator\", \n    values_to = \"values\") %>%\n  tidyr::pivot_wider(\n    names_from = \"period\", \n    values_from = \"values\") %>%\n  dplyr::mutate(\n    Difference = Late - Early\n  ) %>%\n  dplyr::select(-Early, -Late) %>%\n  tidyr::pivot_wider(\n    names_from = \"indicator\", \n    values_from = \"Difference\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 3\n  country avg_unemp avg_gdp\n  <chr>       <dbl>   <dbl>\n1 Austria    -0.346   1899.\n2 Germany    -4.18    3570.\n3 Greece     11.5    -6234.\n4 Italy       3.02   -3014.\n```\n\n\n:::\n:::\n\n\nIf you have trouble understanding the many steps, redo the computations \nyourself and always check what happens in the single steps. It is not a good \nidea to write such a long chain in one working step, but rather to make sure \nthat you always understand what happens in any single step, and then expand \nthe chain one by one.\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}