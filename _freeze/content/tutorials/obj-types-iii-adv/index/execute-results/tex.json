{
  "hash": "195a47b0870c6063edfcaa05f71b4949",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Fundamental object types in R III: Factors and data frames\" # Also check out line 43\nauthor: Claudius Gräbner-Radkowitsch\ndate: '2025-04-04'\ndocumentclass: scrartcl\nformat: \n  html: # Settings set in _metadata.yml\n    toc: true\n  pdf:\n    include-in-header: \n      text: |\n        \\usepackage{lmodern} \n        \\usepackage{graphicx}\n        \\usepackage{hyperref}\n        \\usepackage{url}                \n        \\usepackage{xcolor}\n        \\usepackage{booktabs}\n        \\usepackage{listings}\n        \\lstloadlanguages{R}\n        \n        \\definecolor{eufblue}{RGB}{0,57,91}\n        \\definecolor{eufgrey}{RGB}{111,111,111}\n        \\definecolor{euflightblue}{RGB}{105,170,205}\n        \n        \\hypersetup{\n        pdfauthor={Claudius Graebner-Radkowitsch}\n        colorlinks=true,\n        linkcolor=euflightblue,\n        urlcolor=euflightblue\n        }\n        \\usepackage[includehead,includefoot,top=2cm, bottom=1.5cm]{geometry}\n        \\usepackage[headsepline, footsepline]{scrlayer-scrpage}\n        \\pagestyle{scrheadings}\n        \\clearpairofpagestyles\n        \\ihead{Tutorial: Factors and data frames}\n        %\\chead{Kopfzeile Mitte}\n        \\ohead{\\pagemark} %\n        \\ifoot{}\n        \\cfoot{\\href{https://euf-datascience-spring24.netlify.app/}{\\normalfont\\color{eufblue}{Data Science Using R - Spring Semester 2024}}} % Fußzeile Mitte\n        \\ofoot{} \n        \\setkomafont{disposition}{\\color{eufblue}\\bfseries}\n---\n\n\n# Optional background info: attributes and classes\n\nIn the previous posts you learned about the most important fundamental data \ntypes in `R`.\nThe types we will learn about below and not less important, but less fundamental.\nThis means they are built by taking one of the base types we encountered before,\nand 'adding some features'. These features change the behavior of the type, \ne.g.m how it is printed or how it is affected by certain function calls, but\nalso what kind of operations it allows.^[In fact, some new types allow you to\ndo *less* than the original type, i.e. here the new features are restrictions. \nThe `tibble` we will encounter below is such an example.]\n\nThis process of 'adding features' is usually done by adding 'attributes' to\nan object. In principle, you can add attributes to any objects without\nmuch effect by using the `attr()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 2.0\nattr(x, \"Mood\") <- \"Haha!\"\n```\n:::\n\n\nTo retrieve attributes use `attributes()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattributes(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$Mood\n[1] \"Haha!\"\n```\n\n\n:::\n:::\n\n\nSometimes, adding attributes of a particular name have more relevant \nimplications. \nOne useful way to use attributes, for instance, is to name the single elements \nof vectors,\nsomething that changes the way the objects are printed and something that we \nalready discussed in the context of lists:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- c(1, 2, 3)\nattr(y, \"names\") <- c(\"First\", \"Second\", \"Third\")\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n First Second  Third \n     1      2      3 \n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattributes(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$names\n[1] \"First\"  \"Second\" \"Third\" \n```\n\n\n:::\n:::\n\n\nNow we can call elements by their name:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny[\"Second\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSecond \n     2 \n```\n\n\n:::\n:::\n\n\nBut things become really interesting if you add an attribute called `class`:\nthis really transforms the data types into a new, less fundamental type. In \nfact, this is how the types we discuss below, are created: smart people added,\namong other things, a class attribute to a more fundamental data type \n(`integer` in the case of `factor`s and `list` in the case of `data.frame`s). \nThe art of writing new classes is part of\n[object oriented programming](https://adv-r.hadley.nz/oo.html), an advanced concept \nthat we do not cover in this course (and, to be honest, one of the areas \nwhere `R` is not particularly well designed).\n\nOne implication of this 'less fundamental' nature of the objects we encounter\nbelow is that `typeof()` usually returns the base type. For instance, below\nwe will learn about the `factor`, a type that is built upon `integer`.\nIf we call `typeof()` on a `factor`, it will return the fundamental type,\ni.e. `integer`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxx <- factor(c(1,2))\ntypeof(xx)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n:::\n\n\nFortunately, the standard test functions (`is.*()`) usually work, so you can\nuse `is.factor()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.factor(xx)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\nAlternatively, you can always inspect that attributes of the object to find \nout about its class:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattributes(xx)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$levels\n[1] \"1\" \"2\"\n\n$class\n[1] \"factor\"\n```\n\n\n:::\n:::\n\n\nAll this can be confusing at first, so it is important to keep it in mind. Once \nyou wrapped your head upon this, many confusing behaviors suddenly start to make\nsense, e.g. that mutating factors within a `data.frame` can result in whole \nnumbers, a phenomenon we will discuss in the context of data wrangling later.\n\n# Factors {#introfactors}\n\nWe usually use factors to represent ordinal or categorical data.\nAt first sight a factor is an atomic vector that can only take a pre-specified\nnumber of values, so called *levels*. \nTo create a factor we use the function - surprise - `factor()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"Female\", \"Male\", \"Female\")\nx <- factor(c(\"Female\", \"Male\", \"Female\"))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] Female Male   Female\nLevels: Female Male\n```\n\n\n:::\n:::\n\n\nIf we want to define levels that do not yet have any instances, we can do this \nwith the optional argument `levels`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"Female\", \"Male\", \"Female\")\nx <- factor(c(\"Female\", \"Male\", \"Female\"), \n            levels=c(\"Diverse\",\"Female\", \"Male\"))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] Female Male   Female\nLevels: Diverse Female Male\n```\n\n\n:::\n:::\n\n\nIf we use the argument levels and also try to add values that are not included\nin the levels, these are set to `NA`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"Female\", \"Male\", \"Female\")\nx <- factor(c(\"Female\", \"Male\", \"Female\", \"Diverse\"), \n            levels=c(\"Female\", \"Male\"))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] Female Male   Female <NA>  \nLevels: Female Male\n```\n\n\n:::\n:::\n\n\nUsually, the sequence in which we mention levels does not matter.\nIn the case of ordinal data, however, the sequence becomes important.\nTo consider it, we must use the argument `ordered`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"High\", \"High\", \"Low\", \"High\")\nx <- factor(x, \n            levels = c(\"Low\", \"Mid\", \"High\"), \n            ordered = TRUE)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] High High Low  High\nLevels: Low < Mid < High\n```\n\n\n:::\n:::\n\n\nFrequently, the elements of factors are words, i.e. objects of the type \n`character`.\nFrom a technical point of view, however, factors are stored as `integers`: \nin order to save memory space, each level is assigned a whole number in the \ncomputer memory, which is then mapped to the actual value. \nEspecially when the elements consist of large numbers or long words, this helps \nsaving memory space since these expressions only have to be stored once, and \neach element of the factor is only a simple number.\nTherefore, `typeof()` also returns `integer` for factors:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- factor(c(\"Female\", \"Male\", \"Female\"), \n            levels=c(\"Male\", \"Female\", \"Diverse\"))\ntypeof(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n:::\n\n\nTo check whether an object is a factor we use the function `is.factor()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.factor(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\nNot all operations that are defined for `integer`s, however, also work for \n`factor`s:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[1] + x[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n\nAt the same time, there are some useful things we can do with factors.\nFor instance, the function `table()` gives us the absolute frequencies of the \nfactor elements, a task that is very common for categorical data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nx\n   Male  Female Diverse \n      1       2       0 \n```\n\n\n:::\n:::\n\n\n# Data Frames\n\nThe `data.frame` is a special type of list. It is among the most widespread\ndata types used in data science.\nIn contrast to a normal list, all elements of a `data.frame` must have the same \nlength.\nThis means that you can think of a `data.frame` as a list arranged as a \nrectangle and represented as a table. The headings of the tables then \ncorrespond to the names of the vector elements of the list.\n\nBecause of the close relationship, we can create a `data.frame` directly \nfrom a list by using the function `as.data.frame()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nl_3 <- list(\n  \"a\" = 1:3,\n  \"b\" = 4:6,\n  \"c\" = 7:9\n)\ndf_3 <- as.data.frame(l_3)\n```\n:::\n\n\nHere we might think of the names of the three vectors, `a`, `b` and `c` as the\nheadings of a table (representing, often, variable names), and the content of \nthe vectors as the cell entries of the table:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  a b c\n1 1 4 7\n2 2 5 8\n3 3 6 9\n```\n\n\n:::\n:::\n\n\nThe relation to `list`s becomes obvious if we call `typeof()`, which returns \nthe underlying data type:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(df_3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n:::\n\n\nTo test whether an object is a `data.frame` we use `is.data.frame`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.data.frame(df_3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.data.frame(l_3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\nThe difference to a list becomes particularly obvious in the different \nprinting behavior of the two:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nl_3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$a\n[1] 1 2 3\n\n$b\n[1] 4 5 6\n\n$c\n[1] 7 8 9\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  a b c\n1 1 4 7\n2 2 5 8\n3 3 6 9\n```\n\n\n:::\n:::\n\n\nA more direct way to create a `data.frame` is to use the function \n`data.frame()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_4 <- data.frame(\n  \"gender\" = c(rep(\"male\", 3), rep(\"female\", 2)),\n  \"height\" = c(189, 175, 180, 166, 150)\n)\ndf_4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  gender height\n1   male    189\n2   male    175\n3   male    180\n4 female    166\n5 female    150\n```\n\n\n:::\n:::\n\n\nTo extract single elements, columns or rows of a `data.frame` we can use \n`[` and `[[` in a similar way we used it for lists, just keeping in mind that \nwe now have two dimensions to deal with, instead of only one in the case of lists.\n\nTo subset columns we can call them by name:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_4[\"gender\"] \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  gender\n1   male\n2   male\n3   male\n4 female\n5 female\n```\n\n\n:::\n:::\n\n\nThe result is another `data.frame`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.data.frame(df_4[\"gender\"]) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\nIf we want to extract the underlying atomic vector we must use `[[`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_4[[\"gender\"]] \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"male\"   \"male\"   \"male\"   \"female\" \"female\"\n```\n\n\n:::\n:::\n\n\nThis is also helpful to inspect the underlying data type:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(df_4[[\"gender\"]])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\nData frames can become very large, so its often useful to get a first overview\nabout what the `data.frame` contains. The functions `names()`, `dplyr::glimpse()`, \n`head()`, and `View()` are useful in this context.\n\nThe function `names()` returns a vector with all the column names:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(df_4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"gender\" \"height\"\n```\n\n\n:::\n:::\n\n\n> **Hint:** For large `data.frame`s it can be useful to wrap `names()` into `sort()`, which\nsorts the resulting vector in alphabetical order.\n\nTo print the first `n` rows of a `data.frame` use `head()`. \nBy default `n=5`, but you can set it explicitly:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(df_4, n = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  gender height\n1   male    189\n2   male    175\n```\n\n\n:::\n:::\n\n\nThe package `dplyr` provides the useful function `dplyr::glimpse()`, which \ngives a general overview about all columns and their types:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::glimpse(df_4)\n```\n:::\n\n\nFinally, if you work within R-Studio, you can use `View()` to get a Excel-like\nrepresentation of your data.\n\nAs you might have guessed by now, `data.frame`s are the classic object to \nrepresent read-in data.\nIf, for instance, you download data on GDP in Germany from the Internet and then\nimport this data into `R`, it usually gets represented as a `data.frame`.\nThis representation then allows direct analysis and manipulation of the data.\n\nAt the same time, `data.frame`s are a very old object type, the behavior of\nwhich sometimes feels a bit outdated. Because of this, some authors created \na new data type, which is built upon the `data.frame`, but behaves slightly\ndifferent: the `tibble`. The tibble is made available via the package `tibble`,\nso to use tibbles, this packages has to be installed first.\n\nYou can read more about tibbles in chapter 10 of \n[R for Data Science](https://r4ds.had.co.nz/index.html), i.e. [here](https://r4ds.had.co.nz/tibbles.html) (to avoid confusion: in his book\nHadley always attaches the package `tidyverse` at the beginning of the chapter.\nThis includes attaching the package `tibble`.)\n\n> **Digression: Dialects of R** As with natural languages, programming languages\nfeature different dialects, i.e. different ways of doing the same actions. In\n`R` this becomes particularly obvious in the context of dealing with data. Here,\nthe different dialects show themselfes in different object types used for the\ndata you are working with. To the best of my knowedge, there are three main\ndialects, each associated with a different focus on data representation.\nThe *base* dialect represents data as `data.frame`s and it is the original \napproach envisioned by the `R` developers. The *tidyverse* dialect\nrepresents data as `tibble`s and is built around a number of different packages\nsummarized under the name [tidyverse](https://www.tidyverse.org/). It is aimed\nto develop an set of packages that allow you to do all tasks commonly associated\nwith data science within a consistent syntax and design philosophy.\nThe *data.table* dialect represents data as `data.table`s, which are provided by\nthe package [data.table](https://github.com/Rdatatable/data.table). It is\ndesigned to work with large data sets and is by far the fastest and computationally\nmost efficient approach to data processing. \nIn this course we will follow the `tidyverse` dialect because it is particularly \neasy to learn, widespread, and usually a good default option. Once you mastered\nit and you want to work in the field of big data, you should then consider \nlearning the data table dialect as well. Right now, the most important thing \nis consistency: all the dialects help you to achieve almost any aim you will \never have in the context of data science. But things get very confusing if you\nmix different dialects in practice. Their functions are designed to work well \nwith the other elements of the respective dialect environment, but things can\nbecome confusing if you mix data types and functions from, e.g., the tidyverse \nand data.table dialect. If you want to read more about the controversies associated\nwith the different dialects you might start, e.g.,\n[here](https://github.com/matloff/TidyverseSkeptic) (altough I do not share\nthe opinion of the author regarding teachability).\n\nTransforming `data.frame`s and `tibble`s is one of the central tasks when \ndoing data science, and there are different approaches to it in `R`. Usually,\ntaking your raw data and turnging it into a well formatted `data.frame` is\nnot straightforward and usually takes at least as much time as the final analysis\nof the data. Thus, it is one of the central course objectives to equip you with\nthe tools to facilitate this often underrated and underestimated task. \nBut this will be the main subject of the sessions on *data wrangling*.\n\n# Digression: Matrices in R {#intro-matrix}\n\nAnother data type that is used frequently in many \ncircumstances, especially statistics and engineering, are \nmatrices. These are two-dimensional objects with rows and columns,\neach of which are atomic vectors.^[If you read the section on attributes above:\nmatrices are objects that were given a new attribute `dim`.]\nWe do not deal with matrices\nexplicitly to a large degree, but knowing about how they work\noften turns out useful. Therefore, I provide a quick overview \nbelow, but since matrices are not a central subject of this \ncourse, I leave you with some links to further information.\n\nMatrices are created with the function `matrix()`.\nThis function takes as its first argument the elements of the matrix and then\nthe specification of the number of rows (`nrow`) and/or the number of\ncolumns (`ncol`):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm_1 <- matrix(11:20, nrow = 5)\nm_1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]   11   16\n[2,]   12   17\n[3,]   13   18\n[4,]   14   19\n[5,]   15   20\n```\n\n\n:::\n:::\n\n\nWe can extract and/or substitute the rows and columns as well as \nindividual values as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm_1[,1] # First column\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11 12 13 14 15\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm_1[1,] # First row\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11 16\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm_1[2,2] # Element [2,2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 17\n```\n\n\n:::\n:::\n\n\n> **Hint:** Matrices are built upon atomic vector, which is why `typeof()` \nalways returns the type of the atomic vectors making up the elements:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(m_1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n:::\n\n> As with factors and data frames this has to do with the particular class \nattributes of matrices, which, however is *implicit*:^[This is another piece\nof evidence for the very confusing class concept and object-orientated style\nof `R`. See [this chapter](https://adv-r.hadley.nz/oo.html) for more details, \nin case you are interested.]\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(m_1) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"matrix\" \"array\" \n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattributes(m_1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$dim\n[1] 5 2\n```\n\n\n:::\n:::\n\n\n> To test whether an object is a matrix use `is.matrix()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.matrix(m_1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.matrix(2.0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\nThe most important thing to learn about matrices is matrix algebra. You can\nfind many good introductions in the web, e.g. \n[here](https://www.statmethods.net/advstats/matrix.html)\nor \n[here](https://www.math.uh.edu/~jmorgan/Math6397/day13/LinearAlgebraR-Handout.pdf)\nand, in German, \n[here](https://graebnerc.github.io/RforSocioEcon/formalia.html#formalia-linalg).\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}