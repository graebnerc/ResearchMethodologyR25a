{
  "hash": "83d71b02ffd38a5c6928a896543b2960",
  "result": {
    "markdown": "---\ntitle: \"Exercises for Recap Session 1\"\nsubtitle: \"Possible solutions\"\ndate: \"2024-04-11\"\ndate-modified: last-modified\nformat: \n    html: \n        highlight-style: github\n    pdf: \n        toc: false\n---\n\n\n# Exercise 1: Basic object types I\n\n1. Create a vector containing the numbers `2`, `5`, `2.4` and `11`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nex1_vec <- c(2, 5, 2.4, 11)\n```\n:::\n\n\n2. Replace the second element with `5.9`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nex1_vec[2] <- 5.9\nex1_vec\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  2.0  5.9  2.4 11.0\n```\n:::\n:::\n\n\n3. Add the elements `3` and `1` to the beginning, and the elements \n`\"8.0\"` and `\"9.2\"` to the end of the vector.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nva_1 <- c(3, 1)\nva_2 <- c(\"8.0\", \"9.2\")\nex1_vec_extended <- c(va_1, ex1_vec, va_2)\nex1_vec_extended\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"3\"   \"1\"   \"2\"   \"5.9\" \"2.4\" \"11\"  \"8.0\" \"9.2\"\n```\n:::\n:::\n\n\n4. Create a vector with the numbers from -8 to 9 (step size: 0.5)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nex1_vec_4 <- seq(-8, 9, by = 0.5)\nex1_vec_4\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] -8.0 -7.5 -7.0 -6.5 -6.0 -5.5 -5.0 -4.5 -4.0 -3.5 -3.0 -2.5 -2.0 -1.5 -1.0\n[16] -0.5  0.0  0.5  1.0  1.5  2.0  2.5  3.0  3.5  4.0  4.5  5.0  5.5  6.0  6.5\n[31]  7.0  7.5  8.0  8.5  9.0\n```\n:::\n:::\n\n\n5. Compute the square root of each element of the first vector \nusing vectorisation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt(ex1_vec_4)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in sqrt(ex1_vec_4): NaNs produced\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]       NaN       NaN       NaN       NaN       NaN       NaN       NaN\n [8]       NaN       NaN       NaN       NaN       NaN       NaN       NaN\n[15]       NaN       NaN 0.0000000 0.7071068 1.0000000 1.2247449 1.4142136\n[22] 1.5811388 1.7320508 1.8708287 2.0000000 2.1213203 2.2360680 2.3452079\n[29] 2.4494897 2.5495098 2.6457513 2.7386128 2.8284271 2.9154759 3.0000000\n```\n:::\n:::\n\n\n6. Create a character vector containing then strings `\"Number_1\"` to \n`\"Number_5\"`. Use suitable helper functions to create this vector quickly.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nex1_char_vec <- paste0(\"Number_\", seq(1, 5))\nex1_char_vec\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Number_1\" \"Number_2\" \"Number_3\" \"Number_4\" \"Number_5\"\n```\n:::\n:::\n\n\n# Exercise 2: Basic object types II\n\nConsider the following vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nex_2_vec <- c(1.9, \"2\", FALSE)\n```\n:::\n\n\n1. What is the type of this vector? Why?\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(ex_2_vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n:::\n\n\nAtomic vectors only contain objects of the same type, and there is a \nhierarchy. Elements that themselves are of a type lower in the hierarchy \nare coerced to the same type as the object highest in the hierarchy. The\nhierarchy is as as follows:\n\n1. `character`\n2. `double`\n3. `integer`\n4. `logical`\n\nTherefore, the type of `ex_2_vec` is `character`. The underlying reason is that\nyou can, for instance, always transform a `double` value into a `character` \nbut not vice versa.\n\n2. What happens if you coerce this vector into type integer? Why?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.integer(ex_2_vec)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: NAs introduced by coercion\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  1  2 NA\n```\n:::\n:::\n\n\nBecause `integer` is lower in the hierarchy than `character`, the transformation\nis not straightforward. By coincidence, the first two elements can actually be\ncoerced into integers (albeit maybe not with the expected result), but there is \nno way you can transform the logical value `FALSE` into an integer, which is\nwhy a missing value is produced.\n\n3. What does `sum(is.na(x))` tell you about a vector `x`? What is happening here?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1,2,3,NA,NA,8)\n```\n:::\n\nFirst, `is.na(x)` creates a vector with logical values indicating whether a value of \nthe original vector is missing (i.e. `NA`):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.na(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE FALSE  TRUE  TRUE FALSE\n```\n:::\n:::\n\n\nThen, `sum()` computes the sum over this vecor of boolean values:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(is.na(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n:::\n\n\nHere, `TRUE` counts as one and `FALSE` as zero, so `sum()` gives the number of \ncases in which `is.na(x)` has evaluated to `TRUE`:\n\n\n4. Is it a good idea to use `as.integer()` on double characters to round them to \nthe next integer? Why (not)? What other ways are there to do the rounding?\n\nNo, because `as.integer()` is not acutally rounding numbers (as, for example, `as.integer(2.1)`\nwould make you think), but only removing the decimal part of the number:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.integer(2.9) # you might expect 2...\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n:::\n\n\nBetter use `round()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nround(2.9)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n\n\n\n# Exercise 3: Define a function\n\nCreate functions that take a vector as input and returns:\n\n1. The last value.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_last_val <- function(x){\n  last_val <- x[length(x)]\n  return(last_val)\n}\n```\n:::\n\n\n\n2. Every element except the last value and any missing values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_beginning <- function(x){\n  beginning <- x[-length(x)] # Removes last value\n  na_positions <- which(is.na(beginning)) # Get positions of NA values\n  beginning_nonas <- beginning[-na_positions] # Removes these values\n  return(beginning_nonas)\n} \n```\n:::\n\n\n3. Only even numbers.\n    \n> Hint: Use the operation `x %% y` to get the remainder from diving `x` by `y`, \nthe so called 'modulo y'. For even numbers, the modulo 2 is zero.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_even <- function(x){\n  modulo_2s <- x%%2 # Module 2 is zero for even numbers only\n  even_nbs <- x[modulo_2s==0] # Keep only those for which modulo 2 is zero\n  na_positions <- which(is.na(even_nbs)) # Get positions of NA values\n  even_nbs_nonas <- even_nbs[-na_positions] # Removes these values\n  return(even_nbs_nonas)\n}\n```\n:::\n\n\n\nApply your function to the following example vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nex_3_vec <- c(1, -8, 99, 3, NA, 4, -0.5, 50)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nget_last_val(ex_3_vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 50\n```\n:::\n\n```{.r .cell-code}\nget_beginning(ex_3_vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  1.0 -8.0 99.0  3.0  4.0 -0.5\n```\n:::\n\n```{.r .cell-code}\nget_even(ex_3_vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -8  4 50\n```\n:::\n:::\n\n\n\n# Exercise 4: Lists\n\n1. Create a list that contains three elements called `'a'`, `'b'` and `'c'`.\nThe first element should correspond to a double vector with the elements\n`1.5`, `-2.9` and `99`.\nThe second element should correspond to a character vector with the elments\n`'Hello'`, `'3'`, and `'EUF'`.\nThe third element should contain three times the entry `FALSE`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nex_4_list <- list(\n  'a' = c(1.5, -2.9, 99),\n  'b' = c('Hello', \"'3'\", 'EUF'),\n  'c' = rep(FALSE, 3)\n)\n```\n:::\n\n\n\n2. Transform this list into a `data.frame` and a `tibble`. Then apply `str()` to\nget information about the respective structure. How do the results differ?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nex_4_df <- as.data.frame(ex_4_list)\nex_4_tb <- tibble::as_tibble(ex_4_list)\nstr(ex_4_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 3\n $ a: num [1:3] 1.5 -2.9 99\n $ b: chr [1:3] \"Hello\" \"'3'\" \"EUF\"\n $ c: logi [1:3] FALSE FALSE FALSE\n```\n:::\n\n```{.r .cell-code}\nstr(ex_4_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'data.frame':\t3 obs. of  3 variables:\n $ a: num  1.5 -2.9 99\n $ b: chr  \"Hello\" \"'3'\" \"EUF\"\n $ c: logi  FALSE FALSE FALSE\n```\n:::\n\n```{.r .cell-code}\nstr(ex_4_tb)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntibble [3 Ã— 3] (S3: tbl_df/tbl/data.frame)\n $ a: num [1:3] 1.5 -2.9 99\n $ b: chr [1:3] \"Hello\" \"'3'\" \"EUF\"\n $ c: logi [1:3] FALSE FALSE FALSE\n```\n:::\n:::\n\n\n`str()` only differs with regard to the first line describing the type.\n\n# Exercise 5: Data frames and the study semester distribution at EUF\n\nThe package `DataScienceExercises` contains a data set called `EUFstudentsemesters`,\nwhich contains information about the distribution of study semesters of \nenrolled students at the EUF in 2021. You can shortcut the data set as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\neuf_semesters <- DataScienceExercises::EUFstudentsemesters\n```\n:::\n\n\n1. What happens if you extract the column with study semesters as a vector\nand transform it into a `double`? \n\n\n::: {.cell}\n\n```{.r .cell-code}\nunique(euf_semesters[[\"Semester\"]])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"6\"           \"4\"           \"2\"           \"8\"           \"9 or higher\"\n[6] \"7\"           \"5\"           \"3\"           \"1\"          \n```\n:::\n\n```{.r .cell-code}\nsemesters <- as.double(euf_semesters[[\"Semester\"]])\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: NAs introduced by coercion\n```\n:::\n\n```{.r .cell-code}\nunique(semesters)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  6  4  2  8 NA  7  5  3  1\n```\n:::\n:::\n\n\nWe see that the previous entry `\"9 or higher\"` has been transformed into `NA`.\n\n2. What is the average study semester of those students being in their 8th or \nearlier semester?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(semesters, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4.177026\n```\n:::\n:::\n\n\n\n3. How many students are in their 9th or higher study semester?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(euf_semesters$Semester==\"9 or higher\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 469\n```\n:::\n:::\n\n\n\n4. What does `typeof(euf_semesters)` return and why?\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(euf_semesters)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"list\"\n```\n:::\n:::\n\n\nIt returns `list`, because while `euf_semesters` is a `tibble`, `typeof()`\nalways gives the underlying basic object type. For `tibble`s, this is `list`.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}