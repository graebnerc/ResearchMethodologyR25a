{
  "hash": "ae9aa0bda437812f39e50348e7eb5c4c",
  "result": {
    "markdown": "---\ntitle: \"First recap session\"\nauthor: \"Claudius Gräbner-Radkowitsch\"\ndate: \"2025-04-11\"\ndocumentclass: scrartcl\nformat: \n  html:\n    theme: readable\n    highlight: tango\n    toc: true\n    toc_depth: 2\n    number_sections: true\n  pdf:\n    papersize: a4\n    toc: true\n    toc-depth: 2\n    number-sections: true\n    include-in-header: \n      text: |\n        \\usepackage{lmodern} \n        \\usepackage{graphicx}\n        \\usepackage{hyperref}\n        \\usepackage{url}                \n        \\usepackage{xcolor}\n        \\usepackage{booktabs}\n        \\usepackage{listings}\n        \\lstloadlanguages{R}\n        \n        \\definecolor{eufblue}{RGB}{0,57,91}\n        \\definecolor{eufgrey}{RGB}{111,111,111}\n        \\definecolor{euflightblue}{RGB}{105,170,205}\n        \n        \\hypersetup{\n        pdfauthor={Claudius Graebner-Radkowitsch}\n        colorlinks=true,\n        linkcolor=euflightblue,\n        urlcolor=euflightblue\n        }\n        \\usepackage[includehead,includefoot,top=2cm, bottom=1.5cm]{geometry}\n        \\usepackage[headsepline, footsepline]{scrlayer-scrpage}\n        \\pagestyle{scrheadings}\n        \\clearpairofpagestyles\n        \\ihead{Tutorial: Functions}\n        %\\chead{Kopfzeile Mitte}\n        \\ohead{\\pagemark} %\n        \\ifoot{}\n        \\cfoot{\\href{https://euf-datascience-spring24.netlify.app/}{\\normalfont\\color{eufblue}{Data Science Using R - Spring Semester 2024}}} % Fußzeile Mitte\n        \\ofoot{} \n        \\setkomafont{disposition}{\\color{eufblue}\\bfseries}\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(DataScienceExercises)\n```\n:::\n\n\n\n# Storing and presenting table-like data\n\n> **Question:** \nAfter going through part 2 of the lab I am now a bit confused about the many \nways to display data. \nAre there rules when to use the following options or is it just personal preference?\n`table()`, \n`tibble::as_tibble()`,\n`data.frame()`,\n`dplyr::glimpse()`,\n`head()`,\nand \n`View()`.\n\nThe classical way to store table-like data is the `data.frame`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_1 <- data.frame(\n  \"gender\" = c(rep(\"male\", 5), rep(\"female\", 4)),\n  \"height\" = c(189, 175, 180, 179, 201, 155, 166, 150, 172)\n)\n```\n:::\n\n\nYou can also use the `head()` function to get a quick overview of the first rows of your data set:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(df_1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  gender height\n1   male    189\n2   male    175\n3   male    180\n4   male    179\n5   male    201\n6 female    155\n```\n:::\n:::\n\n\nIf you want to inspect the whole data set in an Excel-like fashion in R Studio,\nyou can use `View()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nView(df_1)\n```\n:::\n\n\nOften, it is a good idea to use a `tibble` instead of a `data.frame`. \nWhile it looks similar, there are a couple of practical advantages of using\n`tibble`s. \n\nYou transform a `data.frame` into a `tibble` using the `tibble::as_tibble()` \nfunction:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntb_1 <- tibble::as_tibble(df_1)\ntb_1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 9 × 2\n  gender height\n  <chr>   <dbl>\n1 male      189\n2 male      175\n3 male      180\n4 male      179\n5 male      201\n6 female    155\n7 female    166\n8 female    150\n9 female    172\n```\n:::\n:::\n\n\nEspecially if you have large data sets, you might want to use the `dplyr::glimpse()` function to get an overview over the overall structure of the data set:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::glimpse(tb_1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 9\nColumns: 2\n$ gender <chr> \"male\", \"male\", \"male\", \"male\", \"male\", \"female\", \"female\", \"fe…\n$ height <dbl> 189, 175, 180, 179, 201, 155, 166, 150, 172\n```\n:::\n:::\n\n\nA similar function is `str()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(tb_1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntibble [9 × 2] (S3: tbl_df/tbl/data.frame)\n $ gender: chr [1:9] \"male\" \"male\" \"male\" \"male\" ...\n $ height: num [1:9] 189 175 180 179 201 155 166 150 172\n```\n:::\n:::\n\n\n**Beware:** There is also a function `table()`, but it is used in a slightly different way.\nYou can use it to create *frequency tables*:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(df_1$gender)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nfemale   male \n     4      5 \n```\n:::\n:::\n\n\n\n# Extracting elements from lists\n\n>  **Question:** I had some difficulty with the coursework task on extracting from lists. It would be helpful to go over that again.\n\nLists are objects that can contain elements of different types. This distinguishes them from atomic vectors.\n\nFor instance, the following does not work:\n\n\n::: {.cell}\n\n```{.r .cell-code}\natomic_vec <- c(1, 5, \"Hey!\", 99)\n```\n:::\n\n\nOr, at least it does not work as one might have intended. Because atomic vectors\ncan only accommodate one type, all elements are coerced to the most basic type that\noccurs. In this case:\n\n\n::: {.cell}\n\n```{.r .cell-code}\natomic_vec\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1\"    \"5\"    \"Hey!\" \"99\"  \n```\n:::\n\n```{.r .cell-code}\ntypeof(atomic_vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n:::\n\n\nLists, on the other hand, can accomodate vectors of different types and lengths:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nl_1 <-  list(1, 5, \"Hey!\", 99)\nl_1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1\n\n[[2]]\n[1] 5\n\n[[3]]\n[1] \"Hey!\"\n\n[[4]]\n[1] 99\n```\n:::\n:::\n\n\nEspecially for more complex lists, the elements are often names:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nl_2 <- list(\n  \"first_numbers\" = c(1, 2, 3, 4),\n  \"second_characters\" = c(\"a\", \"b\", \"c\"),\n  \"third_logical\" = c(TRUE, FALSE, TRUE, TRUE, TRUE)\n)\nl_2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$first_numbers\n[1] 1 2 3 4\n\n$second_characters\n[1] \"a\" \"b\" \"c\"\n\n$third_logical\n[1]  TRUE FALSE  TRUE  TRUE  TRUE\n```\n:::\n:::\n\n\nThere are three ways to extract elemnts from a list, two of which are synonymous:\n\n1. Use `[]` to extract a list element by its name or index. This returns a **list**:\n\n::: {.cell}\n\n```{.r .cell-code}\nl_2[\"second_characters\"] # same effect: l_2[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$second_characters\n[1] \"a\" \"b\" \"c\"\n```\n:::\n:::\n\n\n2. Use `[[]]` to extract a list element by its name or index. This returns the **element**:\n\n::: {.cell}\n\n```{.r .cell-code}\nl_2[[\"second_characters\"]] # same effect: l_2[[2]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\" \"b\" \"c\"\n```\n:::\n:::\n\n\n3. Use `$` to extract a list element by its name. This returns the **element** (so its equivalent to option 2):\n\n::: {.cell}\n\n```{.r .cell-code}\nl_2$second_characters # same effect: l_2[[2]] or l_2[[\"second_characters\"]] \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\" \"b\" \"c\"\n```\n:::\n:::\n\n\n# Creating and using functions\n\n>  **Question:** I’ve reviewed what we’ve covered so far, and I feel that I could benefit from additional practice with functions. I’m still not entirely comfortable with them, and I believe they will be crucial as we progress.\n\n## Using functions\n\nFunctions are algorithms that apply a certain routine on an input, thereby producing (almost always) an output. The function sqrt(), for instance, takes as input a number and returns as output another number, namely the square root of the input:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt(2.5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.581139\n```\n:::\n:::\n\n\nTo call a function we first write its name, followed by parentheses. Inside the parentheses we can specify the arguments of the function.\nMost of the time, the first argument(s) are the input(s).\n\nOften, you can give more arguments to the function. These specify how the algorithm of the function works.\nIf you are not sure which arguments a function accepts, you can always use `help()`.\n\nLet us consider the example of `mean()`. This function takes a vector of numbers as input and returns the mean of these numbers:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_1 <- c(1, 4, 2, 4, 9, NA, 44)\nmean(test_1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n\nThis result might be surprising. Lets inspect `mean()` further:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhelp(mean)\n```\n:::\n\n\nWe see that the first argument of `mean()` is called `x`. We can, but do not\nhave to specify this name for the first argument. Neither we must for the further\nargumens, but this is highly recommended.\n\nThere are two more arguments for `mean()`: `trim` and `na.rm`. \nIn our case, the second one is relevant: if `na.rm` is set to `TRUE`, the function\nremoves all `NA` values from the input before computing the mean:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(test_1, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10.66667\n```\n:::\n:::\n\n\n## Defining functions\n\nWhenever you perform certain actions several times, it is often a good idea to\ndefine a function. This way, you can call the function instead of writing the code for the action every time anew.\n\nAssume we want to define a function that takes as input a vector of numbers and returns the sum of the natural logarithms of these numbers.\n\nWe define a new function by using the function `function()`. \n- We start our definition by associating the new function with a name (here: `log_sum`) so that we can use it later.\n- The arguments to `function()` are then arguments that our new function should accept. In our case, we only have one argument.\n- After that comes the *function body*. It contains all the routines that the function should execute when called. The function body is always enclosed by curly brackets.\n- Finally, we use the `return()` function to specify what the function should return. This is not strictly necessary, but it is a good practice to do so.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlog_sum <- function(input_vector){\n  logs <- log(input_vector)\n  sum_logs <- sum(logs)\n  return(sum_logs)\n}\n```\n:::\n\n\nWe can then call the function by name:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlog_sum(c(1, 2, 3, 4, 5))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4.787492\n```\n:::\n:::\n\n\n\n# Using factors\n\n>  **Question:** If there’s time, I would also appreciate a repetition of factors. While I generally understand the concept, the more complex ones are still a bit confusing to me.\n\nOn a basic level, you can think of a factor as an atomic vector that can only\ntake a pre-specified number of values, so called *levels* . It is often used\nto encode ordinal or categorical data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- factor(c(\"Female\", \"Male\", \"Female\"))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] Female Male   Female\nLevels: Female Male\n```\n:::\n:::\n\n\nBy default, the levels are the unique elements of the input vector. \nBut you can set them also explicitly, which is useful if some levels are missing in the input vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- factor(c(\"Female\", \"Male\", \"Female\"), \n            levels=c(\"Diverse\",\"Female\", \"Male\"))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] Female Male   Female\nLevels: Diverse Female Male\n```\n:::\n:::\n\n\nNote that if you set `levels` explicitly, and the input vector contains an element that is not in the levels, it will be set to `NA`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- factor(c(\"Female\", \"Male\", \"Female\", \"Unknown\"), \n            levels=c(\"Diverse\",\"Female\", \"Male\"))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] Female Male   Female <NA>  \nLevels: Diverse Female Male\n```\n:::\n:::\n\n\n\nYou can use `table()` to get the frequencies for each level:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx\nDiverse  Female    Male \n      0       2       1 \n```\n:::\n:::\n\n\nIf you want the levels to be ordered, you can use the optional argument `ordered\n = TRUE`:\n \n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"High\", \"High\", \"Low\", \"High\")\nx <- factor(x, \n            levels = c(\"Low\", \"Mid\", \"High\"), \n            ordered = TRUE)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] High High Low  High\nLevels: Low < Mid < High\n```\n:::\n:::\n\n\nFactors are not that easy to work with, especially since they are in fact \nnamed `integer`s, a fact that makes their behavior sometimes hard to predict.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n:::\n\n\n\nTherefore, I suggest to code data as factors only if this comes with concrete \nbenefits.\n \n",
    "supporting": [
      "session05-notes_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}