[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Theoretical and Empirical Research Methodology",
    "section": "",
    "text": "ğŸ“‘ The course in brief\nFocus: This course is part of the module Theoretical and Empirical Research Methodology. It complements the theoretical lectures by introducing you to the statistical programming language R and acquire practical knowledge about how to implement essential research tools and all theoretical concepts discussed during the main lecture in R.\nHow: The implementation lab comprises a mixture of (i) lectures, in which I introduce concepts in the classroom, (ii) automated hands-on exercises for you to do at home on your own and (iii) instructional videos for topics that are best learned and practiced by yourself. Of course, you are always invited to post your questions to the course forum on Moodle and more intricate problems can be solved in class.\nPrerequisites: The lab does not require you to have any prior knowledge in R or any other programming language. Depending on your prior knowledge or affinity to programming, the course will be quite demanding, but equip you with computational skills that are most valuable both within academia and the business world.\n\n\nğŸ¯ Learning Objectives\n\nUse R together with the integrated development environment R Studio\nUnderstand the use of R packages to perform specific data analytic tasks\nWrite reproducible data analysis reports using Quarto\nTransform raw data into tidy data, which is suitable for further analysis\nChoose and justify the correct visualization approach, and create appealing visualizations using the R package ggplot2\nImplement and interpret linear regression models with numerical and categorial variables\nAnalyze experimental data in R\n\n\n The main course on moodle"
  },
  {
    "objectID": "content/exercises.html",
    "href": "content/exercises.html",
    "title": "Additional exercises",
    "section": "",
    "text": "Here are some additional exercises, on top of those provided by the exercise package.\n\n\n\n\n\n\n   \n     \n     \n       Order By\n       Default\n         \n          Session date - Oldest\n        \n         \n          Session date - Newest\n        \n         \n          Title\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\nSession date\n\n\nTitle\n\n\n\n\n\n\nMarch 28, 2024\n\n\nBasic object types: exercises\n\n\n\n\nMay 16, 2024\n\n\nQuarto exercises\n\n\n\n\nJune 7, 2024\n\n\nExercises on multiple linear regression\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "content/index.html",
    "href": "content/index.html",
    "title": "Theoretical and Empirical Research Methodology",
    "section": "",
    "text": "ğŸ“ Lecture\nWednesday 14:15-15:45 in MAD 131 & Fridays 14:15-15:45 in MAD 131 (biweekly, see seminar timetable)\nPlease make sure to check out the most recent version of the seminar timetable since lecture dates might differ from one week to another. The most recent version can be found in Moodle.\n\n\nğŸ’» Exercises\nThere is an R package with interactive exercises for this course. I strongly recommend to do the exercises for each session since regular practice is the most important determinant in your success in learning R. You find more information on how to use the exercises in this tutorial. On top of that, there are some additional exercises on selected topics here.\n\n\nğŸ“‚ Material\nYou find an overview about all lecture materials, such as slides and reading lists here. Complete material lists for the single sessions are distributed via the respective session pages. Lecture videos can, so far, only be accessed via Moodle. EUF students can register for the Moodle course 15556 using the password ResearchMethods25.\n\n\nğŸ“– Tutorials\nComplementary to the lectures there are also short tutorials, which explain certain concepts in a more detailed and applied manner. You can find an overview over all tutorials here.\n\n\nğŸ’Œ Contact and discussion\nFor asking questions and starting discussions, please use the forum in Moodle."
  },
  {
    "objectID": "content/tutorials.html",
    "href": "content/tutorials.html",
    "title": "Tutorials",
    "section": "",
    "text": "Here are tutorials, meant to complement the course.\n\n\n\n\n\n\n   \n     \n     \n       Order By\n       Default\n         \n          Session date - Oldest\n        \n         \n          Session date - Newest\n        \n         \n          Title\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\nSession date\n\n\nTitle\n\n\n\n\n\n\nMarch 14, 2025\n\n\nInstallation of the necessary software\n\n\n\n\nMarch 14, 2025\n\n\nInstalling R packages\n\n\n\n\nMarch 14, 2025\n\n\nUsing the exercise package\n\n\n\n\nMarch 21, 2025\n\n\nFirst steps in R\n\n\n\n\nMarch 28, 2025\n\n\nSetting up an R project\n\n\n\n\nApril 4, 2025\n\n\nFundamental object types in R I: Functions\n\n\n\n\nApril 4, 2025\n\n\nFundamental object types in R II: Vectors\n\n\n\n\nApril 4, 2025\n\n\nFundamental object types in R III: Factors and data frames\n\n\n\n\nApril 25, 2025\n\n\nVisualization\n\n\n\n\nMay 16, 2025\n\n\nImporting and exporting data\n\n\n\n\nMay 23, 2025\n\n\nData preparation\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "content/material/index.html",
    "href": "content/material/index.html",
    "title": "Material overview",
    "section": "",
    "text": "The following textbooks offer a good general reference to the course content, and I think its a good idea to read into these books in a general way. Moreover, I often point to chapters in the respective session pages.\n\nWickham, H., Ã‡etinkaya-Rundel, M., & Grolemund, G. (2023). R for data science: Import, tidy, transform, visualize, and model data (2nd edition). Oâ€™Reilly. https://r4ds.hadley.nz/\nIsmay, C., & Kim, A. Y.-S. (2020). Statistical inference via data science: A ModernDive, into R and the tidyverse. CRC Press, Taylor and Francis Group. https://moderndive.com/index.html\n\nFor more advanced details on the fundamentals of programming in R, I recommend the following:\n\nWickham, H. (2019). Advanced R (Second edition). CRC Press/Taylor & Francis Group. https://adv-r.hadley.nz/\n\nFor the model-related parts of the lecture I recommend the following book as a further reading reference:\n\nJames, G., Witten, D., Hastie, T., & Tibshirani, R. (2021). An introduction to statistical learning: With applications in R (Second edition). Springer. https://www.statlearning.com/"
  },
  {
    "objectID": "content/material/index.html#general-references",
    "href": "content/material/index.html#general-references",
    "title": "Material overview",
    "section": "",
    "text": "The following textbooks offer a good general reference to the course content, and I think its a good idea to read into these books in a general way. Moreover, I often point to chapters in the respective session pages.\n\nWickham, H., Ã‡etinkaya-Rundel, M., & Grolemund, G. (2023). R for data science: Import, tidy, transform, visualize, and model data (2nd edition). Oâ€™Reilly. https://r4ds.hadley.nz/\nIsmay, C., & Kim, A. Y.-S. (2020). Statistical inference via data science: A ModernDive, into R and the tidyverse. CRC Press, Taylor and Francis Group. https://moderndive.com/index.html\n\nFor more advanced details on the fundamentals of programming in R, I recommend the following:\n\nWickham, H. (2019). Advanced R (Second edition). CRC Press/Taylor & Francis Group. https://adv-r.hadley.nz/\n\nFor the model-related parts of the lecture I recommend the following book as a further reading reference:\n\nJames, G., Witten, D., Hastie, T., & Tibshirani, R. (2021). An introduction to statistical learning: With applications in R (Second edition). Springer. https://www.statlearning.com/"
  },
  {
    "objectID": "content/material/index.html#session-specific-material",
    "href": "content/material/index.html#session-specific-material",
    "title": "Material overview",
    "section": "ğŸ”– Session-specific material",
    "text": "ğŸ”– Session-specific material\n\n\n\n\n\n\nHow to use the exercise codes?\n\n\n\n\n\nFor information on how to use the exercise code, read this tutorial.\n\n\n\n\n\n\nSession\nTopic\nExercise code\n\n\n\n\n1\nGeneral introduction\n\n\n\n2\nBasics of R and R-Studio\nBasics, Functions\n\n\n3\nProject management\nProjectOrga\n\n\n4\nObject types\nObjectTypes1, ObjectTypes2\n\n\n5\nRecap & practice\n\n\n\n6\nVisualization\nVisualization1\n\n\n7\nQuarto\nQuarto\n\n\n8\nAI for coding\n\n\n\n9\nImporting data\nWrangling1, Wrangling2\n\n\n10\nPreparing data\nWrangling1, Wrangling2\n\n\n11\nTBD\n\n\n\n12\nLinear models\nLinearRegression1, LinearRegression2\n\n\n13\nAnalyzing experimental data\n\n\n\n14\nRecap & practice"
  },
  {
    "objectID": "content/material/session01.html",
    "href": "content/material/session01.html",
    "title": "ğŸ—“ï¸ Session 01 - Introduction, overview and installation",
    "section": "",
    "text": "In this first week, we will cover what you can expect to learn from these exercises and how they differ from the main lecture. I will elaborate a bit on why I chose R for this course, what you can do with it, and what has helped previous participants helped excelling in this course. Finally, I explain a bit what R is, how it relates to R Studio and LaTeX."
  },
  {
    "objectID": "content/material/session01.html#lecture-slides",
    "href": "content/material/session01.html#lecture-slides",
    "title": "ğŸ—“ï¸ Session 01 - Introduction, overview and installation",
    "section": "ğŸ‘¨â€ğŸ« Lecture Slides",
    "text": "ğŸ‘¨â€ğŸ« Lecture Slides\nEither click on the slide area below or click here to download the slides."
  },
  {
    "objectID": "content/material/session01.html#accompanying-lecture-videos",
    "href": "content/material/session01.html#accompanying-lecture-videos",
    "title": "ğŸ—“ï¸ Session 01 - Introduction, overview and installation",
    "section": "ğŸ¥ Accompanying lecture videos",
    "text": "ğŸ¥ Accompanying lecture videos\nAll the videos are available via this playlist.\n\n\n\n\n\n\nExpand to access the videos directly"
  },
  {
    "objectID": "content/material/session01.html#mandatory-reading",
    "href": "content/material/session01.html#mandatory-reading",
    "title": "ğŸ—“ï¸ Session 01 - Introduction, overview and installation",
    "section": "ğŸ“š Mandatory Reading",
    "text": "ğŸ“š Mandatory Reading\nRead the following tutorials:\n\nInstallation of the necessary software\nInstalling R packages\nUsing the exercise package"
  },
  {
    "objectID": "content/material/session01.html#coursework",
    "href": "content/material/session01.html#coursework",
    "title": "ğŸ—“ï¸ Session 01 - Introduction, overview and installation",
    "section": "âœï¸ Coursework",
    "text": "âœï¸ Coursework\n\nMake sure you installed R, R-Studio, Git and all the required R packages\nIf you have questions or problems, please post them in the Moodle forum"
  },
  {
    "objectID": "content/material/session02.html",
    "href": "content/material/session02.html",
    "title": "ğŸ—“ï¸ Session 2: First steps in R",
    "section": "",
    "text": "In this session, you will learn about how to use the integrated development environment R-Studio to edit and execute R script and about the basic commands in R. Moreover, you will be introduced to two fundamental concepts: assignments and functions."
  },
  {
    "objectID": "content/material/session02.html#lecture-slides",
    "href": "content/material/session02.html#lecture-slides",
    "title": "ğŸ—“ï¸ Session 2: First steps in R",
    "section": "ğŸ‘¨â€ğŸ« Lecture Slides",
    "text": "ğŸ‘¨â€ğŸ« Lecture Slides\nEither click on the slide area below or click here to download the slides.\n\n  \n\n\n\n\n\n\n\nThe R script of this session"
  },
  {
    "objectID": "content/material/session02.html#accompanying-lecture-videos",
    "href": "content/material/session02.html#accompanying-lecture-videos",
    "title": "ğŸ—“ï¸ Session 2: First steps in R",
    "section": "ğŸ¥ Accompanying lecture videos",
    "text": "ğŸ¥ Accompanying lecture videos\nAll the videos are available via this playlist.\n\n\n\n\n\n\nExpand to access the videos directly"
  },
  {
    "objectID": "content/material/session02.html#mandatory-reading",
    "href": "content/material/session02.html#mandatory-reading",
    "title": "ğŸ—“ï¸ Session 2: First steps in R",
    "section": "ğŸ“š Mandatory Reading",
    "text": "ğŸ“š Mandatory Reading\n\nTutorial First steps in R\nChapter 2 in Wickham et al. (2023).\n\n\nğŸ† Further readings\n\nR Studio Cheat Sheet\nChapter 4 in Wickham et al. (2023).\nChapter 8 in Wickham et al. (2023)."
  },
  {
    "objectID": "content/material/session02.html#coursework",
    "href": "content/material/session02.html#coursework",
    "title": "ğŸ—“ï¸ Session 2: First steps in R",
    "section": "âœï¸ Coursework",
    "text": "âœï¸ Coursework\n\nDo the Basics exercises of the package DataScienceExercises\n\n\n\n\n\n\n\nQuick code for starting the exercises\n\n\n\n\n\n\nlearnr::run_tutorial(\n  name = \"Basics\", \n  package = \"DataScienceExercises\", \n  shiny_args=list(\"launch.browser\"=TRUE))\n\n\n\n\n\nDo the Functions exercises of the package DataScienceExercises\n\n\n\n\n\n\n\nQuick code for starting the exercises\n\n\n\n\n\n\nlearnr::run_tutorial(\n  name = \"Functions\", \n  package = \"DataScienceExercises\", \n  shiny_args=list(\"launch.browser\"=TRUE))\n\n\n\n\n\nIf you have questions or problems, please post them in the Moodle forum"
  },
  {
    "objectID": "content/material/session03.html",
    "href": "content/material/session03.html",
    "title": "ğŸ—“ï¸ Session 3: Project management",
    "section": "",
    "text": "This is one of the most underestimated topics. In this session you learn how to adequately set up your working environment on your computer. This means where you should save which files, which directory structure you should use, and how to point the computer to other files on your computer. While this sounds boring at first, taking seriously the insights from this session will save you tons of hours of frustration in the future!"
  },
  {
    "objectID": "content/material/session03.html#lecture-slides",
    "href": "content/material/session03.html#lecture-slides",
    "title": "ğŸ—“ï¸ Session 3: Project management",
    "section": "ğŸ‘¨â€ğŸ« Lecture Slides",
    "text": "ğŸ‘¨â€ğŸ« Lecture Slides\nEither click on the slide area below or click here to download the slides.\n\n  \n\n\n\n\n\n\n\nLecture script"
  },
  {
    "objectID": "content/material/session03.html#lecture-videos",
    "href": "content/material/session03.html#lecture-videos",
    "title": "ğŸ—“ï¸ Session 3: Project management",
    "section": "ğŸ¥ Lecture videos",
    "text": "ğŸ¥ Lecture videos\nCurrently, no videos are available for this session. Check out the tutorial on project setup instead."
  },
  {
    "objectID": "content/material/session03.html#mandatory-reading",
    "href": "content/material/session03.html#mandatory-reading",
    "title": "ğŸ—“ï¸ Session 3: Project management",
    "section": "ğŸ“š Mandatory Reading",
    "text": "ğŸ“š Mandatory Reading\n\nThe tutorial Setting up an R project"
  },
  {
    "objectID": "content/material/session03.html#further-reading",
    "href": "content/material/session03.html#further-reading",
    "title": "ğŸ—“ï¸ Session 3: Project management",
    "section": "Further Reading",
    "text": "Further Reading\nWhile we do not cover this in this course, I highly recommend learning the version control system Git. Personally, I can recommend the following:\n\nVery concise introduction to Git\nIntroduction to GitHub: GitHub skills and the official docs"
  },
  {
    "objectID": "content/material/session03.html#coursework",
    "href": "content/material/session03.html#coursework",
    "title": "ğŸ—“ï¸ Session 3: Project management",
    "section": "âœï¸ Coursework",
    "text": "âœï¸ Coursework\n\nDo the exercises ProjectOrga from the DataScienceExercises package that refer to setting up an R project\nIf you still have problems with R Packages, re-read the respective section of the tutorial from session 2\n\n\n\n\n\n\n\nQuick code for starting the exercises\n\n\n\n\n\n\nlearnr::run_tutorial(\n  name = \"ProjectOrga\", \n  package = \"DataScienceExercises\", \n  shiny_args=list(\"launch.browser\"=TRUE))"
  },
  {
    "objectID": "content/material/session04.html",
    "href": "content/material/session04.html",
    "title": "ğŸ—“ï¸ Session 4: Object types in R",
    "section": "",
    "text": "In the first part of this session you learn some additional details about R packages and about the most important and most fundamental object types in R, such as decimal numbers or words. While this might look a bit boring at first, understanding these basic types is fundamental for all the more advanced (and exiting) stuff in the future!\nIn the second part of this session, you are then introduced to two more advanced object types in R. The two object types covered, factors and data frames, are advanced in the sense that they can be thought of extensions of some of the basic object types you encountered before: factors and special kinds of integers, and data frames are special kinds of lists."
  },
  {
    "objectID": "content/material/session04.html#lecture-slides",
    "href": "content/material/session04.html#lecture-slides",
    "title": "ğŸ—“ï¸ Session 4: Object types in R",
    "section": "ğŸ‘¨â€ğŸ« Lecture Slides",
    "text": "ğŸ‘¨â€ğŸ« Lecture Slides\nFor the slides of the first part of this session (Packages and basic object types) on click on the slide area below or click here to download the slides.\n\n  \n\n\n\n\n\n\n\nSolutions to the intermediate exercises of part 1\n\n\n\n\n\n\n\n\n\nFor the slides of the second part of this session (Advanced object types) on click on the slide area below or click here to download the slides.\n\n  \n\n\n\n\n\n\n\nNotes and solutions for the second part of this session"
  },
  {
    "objectID": "content/material/session04.html#lecture-videos",
    "href": "content/material/session04.html#lecture-videos",
    "title": "ğŸ—“ï¸ Session 4: Object types in R",
    "section": "ğŸ¥ Lecture videos",
    "text": "ğŸ¥ Lecture videos\nAll the videos for the first part on basic object types are available via this playlist.\n\n\n\n\n\n\nExpand to access the videos directly\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAll the videos for the second part on advanced object types are available via this playlist.\n\n\n\n\n\n\nExpand to access the videos directly"
  },
  {
    "objectID": "content/material/session04.html#mandatory-reading",
    "href": "content/material/session04.html#mandatory-reading",
    "title": "ğŸ—“ï¸ Session 4: Object types in R",
    "section": "ğŸ“š Mandatory Reading",
    "text": "ğŸ“š Mandatory Reading\nRead the following tutorials for the first part on basic object types:\n\nFundamental object types in R I: Functions\nFundamental object types in R II: Vectors\n\nThe topics of the second part on advanced object types are covered here:\n\nFundamental object types in R III: Factors and data frames\n\n\nğŸ† Further readings\nI suggest you read these references after you learned about data wrangling techniques in session 10.\n\nSections 1-3 in Chapter 12 of Wickham et al. (2023).\nChapter 13 in Wickham et al. (2023).\nChapter 14 in Wickham et al. (2023).\nChapter 16 in Wickham et al. (2023)."
  },
  {
    "objectID": "content/material/session04.html#coursework",
    "href": "content/material/session04.html#coursework",
    "title": "ğŸ—“ï¸ Session 4: Object types in R",
    "section": "âœï¸ Coursework",
    "text": "âœï¸ Coursework\n\nDo the ObjectTypes1 exercises of the package DataScienceExercises for the first part on basic object types:\n\n\n\n\n\n\n\nQuick code for starting the exercises\n\n\n\n\n\n\nlearnr::run_tutorial(\n  name = \"ObjectTypes1\", \n  package = \"DataScienceExercises\", \n  shiny_args=list(\"launch.browser\"=TRUE))\n\n\n\n\n\nFor the second part do the ObjectTypes2 exercises of the package DataScienceExercises\n\n\n\n\n\n\n\nQuick code for starting the exercises\n\n\n\n\n\n\nlearnr::run_tutorial(\n  name = \"ObjectTypes2\", \n  package = \"DataScienceExercises\", \n  shiny_args=list(\"launch.browser\"=TRUE))\n\n\n\n\n\nIf you have questions or problems, please post them in the Moodle forum"
  },
  {
    "objectID": "content/material/session05-exercises.html",
    "href": "content/material/session05-exercises.html",
    "title": "Exercises for Recap Session 1",
    "section": "",
    "text": "Exercise 1: Basic object types I\n\nCreate a vector containing the numbers 2, 5, 2.4 and 11.\nReplace the second element with 5.9.\nAdd the elements 3 and 1 to the beginning, and the elements \"8.0\" and \"9.2\" to the end of the vector.\nCreate a vector with the numbers from -8 to 9 (step size: 0.5)\nCompute the square root of each element of the first vector using vectorisation.\nCreate a character vector containing then strings \"Number_1\" to \"Number_5\". Use suitable helper functions to create this vector quickly.\n\n\n\nExercise 2: Basic object types II\nConsider the following vector:\n\nex_2_vec &lt;- c(1, \"2\", FALSE)\n\n\nWhat is the type of this vector? Why?\nWhat happens if you coerce this vector into type integer? Why?\nWhat does sum(is.na(x)) tell you about a vector x? What is happening here?\nIs it a good idea to use as.integer() on double characters to round them to the next integer? Why (not)? What other ways are there to do the rounding?\n\n\n\nExercise 3: Define a function\nCreate functions that take a vector as input and returns:\n\nThe last value.\nEvery element except the last value and any missing values.\nOnly even numbers.\n\n\nHint: Use the operation x %% y to get the remainder from diving x by y, the so called â€˜modulo yâ€™. For even numbers, the modulo 2 is zero.\n\nApply your function to the following example vector:\n\nex_3_vec &lt;- c(1, -8, 99, 3, NA, 3, -0.5)\n\n\n\nExercise 4: Lists\n\nCreate a list that contains three elements called 'a', 'b' and 'c'. The first element should correspond to a double vector with the elements 1.5, -2.9 and 99. The second element should correspond to a character vector with the elments 'Hello', '3', and 'EUF'. The third element should contain three times the entry FALSE.\nTransform this list into a data.frame and a tibble. Then apply str() to get information about the respective structure. How do the results differ?\n\n\n\nExercise 5: Data frames and the study semester distribution at EUF\nThe package DataScienceExercises contains a data set called EUFstudentsemesters, which contains information about the distribution of study semesters of enrolled students at the EUF in 2021. You can shortcut the data set as follows:\n\neuf_semesters &lt;- DataScienceExercises::EUFstudentsemesters\n\n\nWhat happens if you extract the column with study semesters as a vector and transform it into a double?\nWhat is the average study semester of those students being in their 8th or earlier semester?\nHow many students are in their 9th or higher study semester?\nWhat does typeof(euf_semesters) return and why?"
  },
  {
    "objectID": "content/material/session05-solutions.html",
    "href": "content/material/session05-solutions.html",
    "title": "Exercises for Recap Session 1",
    "section": "",
    "text": "Exercise 1: Basic object types I\n\nCreate a vector containing the numbers 2, 5, 2.4 and 11.\n\n\nex1_vec &lt;- c(2, 5, 2.4, 11)\n\n\nReplace the second element with 5.9.\n\n\nex1_vec[2] &lt;- 5.9\nex1_vec\n\n[1]  2.0  5.9  2.4 11.0\n\n\n\nAdd the elements 3 and 1 to the beginning, and the elements \"8.0\" and \"9.2\" to the end of the vector.\n\n\nva_1 &lt;- c(3, 1)\nva_2 &lt;- c(\"8.0\", \"9.2\")\nex1_vec_extended &lt;- c(va_1, ex1_vec, va_2)\nex1_vec_extended\n\n[1] \"3\"   \"1\"   \"2\"   \"5.9\" \"2.4\" \"11\"  \"8.0\" \"9.2\"\n\n\n\nCreate a vector with the numbers from -8 to 9 (step size: 0.5)\n\n\nex1_vec_4 &lt;- seq(-8, 9, by = 0.5)\nex1_vec_4\n\n [1] -8.0 -7.5 -7.0 -6.5 -6.0 -5.5 -5.0 -4.5 -4.0 -3.5 -3.0 -2.5 -2.0 -1.5 -1.0\n[16] -0.5  0.0  0.5  1.0  1.5  2.0  2.5  3.0  3.5  4.0  4.5  5.0  5.5  6.0  6.5\n[31]  7.0  7.5  8.0  8.5  9.0\n\n\n\nCompute the square root of each element of the first vector using vectorisation.\n\n\nsqrt(ex1_vec_4)\n\nWarning in sqrt(ex1_vec_4): NaNs produced\n\n\n [1]       NaN       NaN       NaN       NaN       NaN       NaN       NaN\n [8]       NaN       NaN       NaN       NaN       NaN       NaN       NaN\n[15]       NaN       NaN 0.0000000 0.7071068 1.0000000 1.2247449 1.4142136\n[22] 1.5811388 1.7320508 1.8708287 2.0000000 2.1213203 2.2360680 2.3452079\n[29] 2.4494897 2.5495098 2.6457513 2.7386128 2.8284271 2.9154759 3.0000000\n\n\n\nCreate a character vector containing then strings \"Number_1\" to \"Number_5\". Use suitable helper functions to create this vector quickly.\n\n\nex1_char_vec &lt;- paste0(\"Number_\", seq(1, 5))\nex1_char_vec\n\n[1] \"Number_1\" \"Number_2\" \"Number_3\" \"Number_4\" \"Number_5\"\n\n\n\n\nExercise 2: Basic object types II\nConsider the following vector:\n\nex_2_vec &lt;- c(1.9, \"2\", FALSE)\n\n\nWhat is the type of this vector? Why?\n\n\ntypeof(ex_2_vec)\n\n[1] \"character\"\n\n\nAtomic vectors only contain objects of the same type, and there is a hierarchy. Elements that themselves are of a type lower in the hierarchy are coerced to the same type as the object highest in the hierarchy. The hierarchy is as as follows:\n\ncharacter\ndouble\ninteger\nlogical\n\nTherefore, the type of ex_2_vec is character. The underlying reason is that you can, for instance, always transform a double value into a character but not vice versa.\n\nWhat happens if you coerce this vector into type integer? Why?\n\n\nas.integer(ex_2_vec)\n\nWarning: NAs introduced by coercion\n\n\n[1]  1  2 NA\n\n\nBecause integer is lower in the hierarchy than character, the transformation is not straightforward. By coincidence, the first two elements can actually be coerced into integers (albeit maybe not with the expected result), but there is no way you can transform the logical value FALSE into an integer, which is why a missing value is produced.\n\nWhat does sum(is.na(x)) tell you about a vector x? What is happening here?\n\n\nx &lt;- c(1,2,3,NA,NA,8)\n\nFirst, is.na(x) creates a vector with logical values indicating whether a value of the original vector is missing (i.e.Â NA):\n\nis.na(x)\n\n[1] FALSE FALSE FALSE  TRUE  TRUE FALSE\n\n\nThen, sum() computes the sum over this vecor of boolean values:\n\nsum(is.na(x))\n\n[1] 2\n\n\nHere, TRUE counts as one and FALSE as zero, so sum() gives the number of cases in which is.na(x) has evaluated to TRUE:\n\nIs it a good idea to use as.integer() on double characters to round them to the next integer? Why (not)? What other ways are there to do the rounding?\n\nNo, because as.integer() is not acutally rounding numbers (as, for example, as.integer(2.1) would make you think), but only removing the decimal part of the number:\n\nas.integer(2.9) # you might expect 2...\n\n[1] 2\n\n\nBetter use round():\n\nround(2.9)\n\n[1] 3\n\n\n\n\nExercise 3: Define a function\nCreate functions that take a vector as input and returns:\n\nThe last value.\n\n\nget_last_val &lt;- function(x){\n  last_val &lt;- x[length(x)]\n  return(last_val)\n}\n\n\nEvery element except the last value and any missing values.\n\n\nget_beginning &lt;- function(x){\n  beginning &lt;- x[-length(x)] # Removes last value\n  na_positions &lt;- which(is.na(beginning)) # Get positions of NA values\n  beginning_nonas &lt;- beginning[-na_positions] # Removes these values\n  return(beginning_nonas)\n} \n\n\nOnly even numbers.\n\n\nHint: Use the operation x %% y to get the remainder from diving x by y, the so called â€˜modulo yâ€™. For even numbers, the modulo 2 is zero.\n\n\nget_even &lt;- function(x){\n  modulo_2s &lt;- x%%2 # Module 2 is zero for even numbers only\n  even_nbs &lt;- x[modulo_2s==0] # Keep only those for which modulo 2 is zero\n  na_positions &lt;- which(is.na(even_nbs)) # Get positions of NA values\n  even_nbs_nonas &lt;- even_nbs[-na_positions] # Removes these values\n  return(even_nbs_nonas)\n}\n\nApply your function to the following example vector:\n\nex_3_vec &lt;- c(1, -8, 99, 3, NA, 4, -0.5, 50)\n\n\nget_last_val(ex_3_vec)\n\n[1] 50\n\nget_beginning(ex_3_vec)\n\n[1]  1.0 -8.0 99.0  3.0  4.0 -0.5\n\nget_even(ex_3_vec)\n\n[1] -8  4 50\n\n\n\n\nExercise 4: Lists\n\nCreate a list that contains three elements called 'a', 'b' and 'c'. The first element should correspond to a double vector with the elements 1.5, -2.9 and 99. The second element should correspond to a character vector with the elments 'Hello', '3', and 'EUF'. The third element should contain three times the entry FALSE.\n\n\nex_4_list &lt;- list(\n  'a' = c(1.5, -2.9, 99),\n  'b' = c('Hello', \"'3'\", 'EUF'),\n  'c' = rep(FALSE, 3)\n)\n\n\nTransform this list into a data.frame and a tibble. Then apply str() to get information about the respective structure. How do the results differ?\n\n\nex_4_df &lt;- as.data.frame(ex_4_list)\nex_4_tb &lt;- tibble::as_tibble(ex_4_list)\nstr(ex_4_list)\n\nList of 3\n $ a: num [1:3] 1.5 -2.9 99\n $ b: chr [1:3] \"Hello\" \"'3'\" \"EUF\"\n $ c: logi [1:3] FALSE FALSE FALSE\n\nstr(ex_4_df)\n\n'data.frame':   3 obs. of  3 variables:\n $ a: num  1.5 -2.9 99\n $ b: chr  \"Hello\" \"'3'\" \"EUF\"\n $ c: logi  FALSE FALSE FALSE\n\nstr(ex_4_tb)\n\ntibble [3 Ã— 3] (S3: tbl_df/tbl/data.frame)\n $ a: num [1:3] 1.5 -2.9 99\n $ b: chr [1:3] \"Hello\" \"'3'\" \"EUF\"\n $ c: logi [1:3] FALSE FALSE FALSE\n\n\nstr() only differs with regard to the first line describing the type.\n\n\nExercise 5: Data frames and the study semester distribution at EUF\nThe package DataScienceExercises contains a data set called EUFstudentsemesters, which contains information about the distribution of study semesters of enrolled students at the EUF in 2021. You can shortcut the data set as follows:\n\neuf_semesters &lt;- DataScienceExercises::EUFstudentsemesters\n\n\nWhat happens if you extract the column with study semesters as a vector and transform it into a double?\n\n\nunique(euf_semesters[[\"Semester\"]])\n\n[1] \"6\"           \"4\"           \"2\"           \"8\"           \"9 or higher\"\n[6] \"7\"           \"5\"           \"3\"           \"1\"          \n\nsemesters &lt;- as.double(euf_semesters[[\"Semester\"]])\n\nWarning: NAs introduced by coercion\n\nunique(semesters)\n\n[1]  6  4  2  8 NA  7  5  3  1\n\n\nWe see that the previous entry \"9 or higher\" has been transformed into NA.\n\nWhat is the average study semester of those students being in their 8th or earlier semester?\n\n\nmean(semesters, na.rm = TRUE)\n\n[1] 4.177026\n\n\n\nHow many students are in their 9th or higher study semester?\n\n\nsum(euf_semesters$Semester==\"9 or higher\")\n\n[1] 469\n\n\n\nWhat does typeof(euf_semesters) return and why?\n\n\ntypeof(euf_semesters)\n\n[1] \"list\"\n\n\nIt returns list, because while euf_semesters is a tibble, typeof() always gives the underlying basic object type. For tibbles, this is list."
  },
  {
    "objectID": "content/material/session05.html",
    "href": "content/material/session05.html",
    "title": "ğŸ—“ï¸ Session 5: Recap and practice",
    "section": "",
    "text": "This session is about recap and practice. We will do exercises on topics that you suggest, and recap concepts you found particularly hard to grasp. To this end, make sure you communicate your preferences on topics via Moodle until one week before this session."
  },
  {
    "objectID": "content/material/session05.html#lecture-slides",
    "href": "content/material/session05.html#lecture-slides",
    "title": "ğŸ—“ï¸ Session 5: Recap and practice",
    "section": "ğŸ‘¨â€ğŸ« Lecture Slides",
    "text": "ğŸ‘¨â€ğŸ« Lecture Slides\nTBA"
  },
  {
    "objectID": "content/material/session05.html#lecture-videos",
    "href": "content/material/session05.html#lecture-videos",
    "title": "ğŸ—“ï¸ Session 5: Recap and practice",
    "section": "ğŸ¥ Lecture videos",
    "text": "ğŸ¥ Lecture videos\nThere will be no videos for recap sessions."
  },
  {
    "objectID": "content/material/session05.html#suggested-reading",
    "href": "content/material/session05.html#suggested-reading",
    "title": "ğŸ—“ï¸ Session 5: Recap and practice",
    "section": "ğŸ“š Suggested Reading",
    "text": "ğŸ“š Suggested Reading\n\nThe tutorial Setting up an R project\nFundamental object types in R I: Functions\nThe section on lists in Fundamental object types in R II: Vectors\nThe section on factors in Fundamental object types in R III: Factors and data frames"
  },
  {
    "objectID": "content/material/session05.html#coursework",
    "href": "content/material/session05.html#coursework",
    "title": "ğŸ—“ï¸ Session 5: Recap and practice",
    "section": "âœï¸ Coursework",
    "text": "âœï¸ Coursework\nDuring the fthe session you will work on this sheet in groups of three people. Please use only one computer but develop the solutions together. LAter we will go through your solutions and discuss problems. I will post my own solutions online after the session, but urge to first try to come up with solutions on your own.\n\nExercise sheet for this session\nR file template for your solutions"
  },
  {
    "objectID": "content/material/session06.html",
    "href": "content/material/session06.html",
    "title": "ğŸ—“ï¸ Session 6: Visualization",
    "section": "",
    "text": "One area for which R is particulary well-known for is the area of visualization. This is particularly because of the package ggplot2. This session introduces ggplot2 and the general approach to generate visualization in R. The good thing is that if you follow the approach described here, you can basically create every visualization type you can think of."
  },
  {
    "objectID": "content/material/session06.html#lecture-slides",
    "href": "content/material/session06.html#lecture-slides",
    "title": "ğŸ—“ï¸ Session 6: Visualization",
    "section": "ğŸ‘¨â€ğŸ« Lecture Slides",
    "text": "ğŸ‘¨â€ğŸ« Lecture Slides\nEither click on the slide area below or click here to download the slides.\n\n  \n\n\n\n\n\n\n\nThe R script of this session"
  },
  {
    "objectID": "content/material/session06.html#lecture-videos",
    "href": "content/material/session06.html#lecture-videos",
    "title": "ğŸ—“ï¸ Session 6: Visualization",
    "section": "ğŸ¥ Lecture videos",
    "text": "ğŸ¥ Lecture videos\nCurrently, no videos are available for this session. Check out the tutorial instead."
  },
  {
    "objectID": "content/material/session06.html#mandatory-reading",
    "href": "content/material/session06.html#mandatory-reading",
    "title": "ğŸ—“ï¸ Session 6: Visualization",
    "section": "ğŸ“š Mandatory Reading",
    "text": "ğŸ“š Mandatory Reading\n\nThe tutorial visualization"
  },
  {
    "objectID": "content/material/session06.html#further-reading",
    "href": "content/material/session06.html#further-reading",
    "title": "ğŸ—“ï¸ Session 6: Visualization",
    "section": "Further Reading",
    "text": "Further Reading\n\nWickham (2010), who introduces the theory underlying ggplot2\nggplot2 cheat sheet\nBrowse the website from Data to Viz and try to re-create some of the figures yourself"
  },
  {
    "objectID": "content/material/session06.html#coursework",
    "href": "content/material/session06.html#coursework",
    "title": "ğŸ—“ï¸ Session 6: Visualization",
    "section": "âœï¸ Coursework",
    "text": "âœï¸ Coursework\n\nDo the exercises Visualization1 from the DataScienceExercises package\n\n\n\n\n\n\n\nQuick code for starting the exercises\n\n\n\n\n\n\nlearnr::run_tutorial(\n  name = \"Visualization1\", \n  package = \"DataScienceExercises\", \n  shiny_args=list(\"launch.browser\"=TRUE))"
  },
  {
    "objectID": "content/material/session07.html",
    "href": "content/material/session07.html",
    "title": "ğŸ—“ï¸ Session 7: A very short introduction to Quarto",
    "section": "",
    "text": "Quarto is a modern multi-language version of R Markdown. As with its predecessor, the idea is to provide people with the opportunity to write text and code into the very same document. This makes the creation of nice looking and reproducible reports or paper very easy. Moreoever, with Quarto it is very easy to create very nice papers, reports, websites or interactive apps. This website, for example, is fully written in Quarto. In this lecture, you learn everything you need to get started with writing your first Quarto documents. In fact, its really straighforward once you get the basic idea."
  },
  {
    "objectID": "content/material/session07.html#lecture-slides",
    "href": "content/material/session07.html#lecture-slides",
    "title": "ğŸ—“ï¸ Session 7: A very short introduction to Quarto",
    "section": "ğŸ‘¨â€ğŸ« Lecture Slides",
    "text": "ğŸ‘¨â€ğŸ« Lecture Slides\nEither click on the slide area below or click here to download the slides.\n\n  \n\n\nDesasterMarkdown.pdf\nNicerMarkdown.pdf\n\n\n\n\n\n\n\nCode for the markdown desaster and a possible solution"
  },
  {
    "objectID": "content/material/session07.html#lecture-videos",
    "href": "content/material/session07.html#lecture-videos",
    "title": "ğŸ—“ï¸ Session 7: A very short introduction to Quarto",
    "section": "ğŸ¥ Lecture videos",
    "text": "ğŸ¥ Lecture videos\nSo far, there are no learning videos available for this lecture."
  },
  {
    "objectID": "content/material/session07.html#mandatory-reading",
    "href": "content/material/session07.html#mandatory-reading",
    "title": "ğŸ—“ï¸ Session 7: A very short introduction to Quarto",
    "section": "ğŸ“š Mandatory Reading",
    "text": "ğŸ“š Mandatory Reading\n\nThe CommonMark markdown tutorial\nQuarto tutorial I: the basics\nQuarto tutorial II: computations\nQuarto tutorial III: authoring quarto documents"
  },
  {
    "objectID": "content/material/session07.html#further-reading",
    "href": "content/material/session07.html#further-reading",
    "title": "ğŸ—“ï¸ Session 7: A very short introduction to Quarto",
    "section": "Further Reading",
    "text": "Further Reading\n\nBlog introducing Quarto\nQuarto and R Markdown\nThe comprehensive Quarto documentation\nMarkdown basics\nThe R Markdown Cookbook"
  },
  {
    "objectID": "content/material/session07.html#coursework",
    "href": "content/material/session07.html#coursework",
    "title": "ğŸ—“ï¸ Session 7: A very short introduction to Quarto",
    "section": "âœï¸ Coursework",
    "text": "âœï¸ Coursework\n\nDo the exercises Quarto from the DataScienceExercises package\n\n\n\n\n\n\n\nQuick code for starting the exercises\n\n\n\n\n\n\nlearnr::run_tutorial(\n  name = \"Quarto\", \n  package = \"DataScienceExercises\", \n  shiny_args=list(\"launch.browser\"=TRUE))\n\n\n\n\n\nDo the following practical exercise:\n\n\n\n\n\n\n\nExercise description\n\n\n\n\n\nCreate a new Quarto document where you set the title, date, and the author explicitly. Write a sample text that comprisesâ€¦\n\nâ€¦at least one level 1 heading\nâ€¦at least two level 2 headings\nâ€¦a YAML part that specifies that R code remains hidden by default\nâ€¦one R chunk where both the output and the code is printed in the final document\nâ€¦one R chunk that produces a simply ggplot object and where the code producing the plot is hidden\n\nThen do the following:\n\nKnit the document to html with a floating table of contents and a special theme.\nMake the document available via Netlify Drop and add the possibility to download the underlying Rmd file. &gt; Note: For Netlify Drop to work, the html file must be called `index.html```!\nKnit the document to PDF and make sure that it includes a table of contents.\n\n\n\n\n\n\n\n\n\n\nPossible solution"
  },
  {
    "objectID": "content/material/session08.html",
    "href": "content/material/session08.html",
    "title": "ğŸ—“ï¸ Session 8: Using AI for coding",
    "section": "",
    "text": "In this lecture you learn the basics of using AI tools for coding tasks. While no AI tool will help you to write code in a language you do not understand, modern AI tools are well suited to assist you in writing code in a language you are familiar with. Here we discuss some of the most common use cases for AI when it comes to the development of R code. We focus on, first, getting a first sketch of an R script and, second, on using AI to help you find mistakes in your current code. We highlight how important it is to provide the AI with context - something you can only do if you already know the basics of the programming language you and the AI are working with."
  },
  {
    "objectID": "content/material/session08.html#lecture-slides",
    "href": "content/material/session08.html#lecture-slides",
    "title": "ğŸ—“ï¸ Session 8: Using AI for coding",
    "section": "ğŸ‘¨â€ğŸ« Lecture Slides",
    "text": "ğŸ‘¨â€ğŸ« Lecture Slides\nTBA"
  },
  {
    "objectID": "content/material/session08.html#lecture-videos",
    "href": "content/material/session08.html#lecture-videos",
    "title": "ğŸ—“ï¸ Session 8: Using AI for coding",
    "section": "ğŸ¥ Lecture videos",
    "text": "ğŸ¥ Lecture videos\nSo far, there are no learning videos available for this lecture."
  },
  {
    "objectID": "content/material/session08.html#mandatory-reading",
    "href": "content/material/session08.html#mandatory-reading",
    "title": "ğŸ—“ï¸ Session 8: Using AI for coding",
    "section": "ğŸ“š Mandatory Reading",
    "text": "ğŸ“š Mandatory Reading\n\nTBA"
  },
  {
    "objectID": "content/material/session08.html#further-reading",
    "href": "content/material/session08.html#further-reading",
    "title": "ğŸ—“ï¸ Session 8: Using AI for coding",
    "section": "Further Reading",
    "text": "Further Reading\n\nTBA"
  },
  {
    "objectID": "content/material/session08.html#coursework",
    "href": "content/material/session08.html#coursework",
    "title": "ğŸ—“ï¸ Session 8: Using AI for coding",
    "section": "âœï¸ Coursework",
    "text": "âœï¸ Coursework\n\nTBA"
  },
  {
    "objectID": "content/material/session09.html",
    "href": "content/material/session09.html",
    "title": "ğŸ—“ï¸ Session 9: Importing data",
    "section": "",
    "text": "This is also one of the most underestimated topics. This session builds upon the previous session on setting up a project environment. Now you will learn how to import data obtained elsewhere into R. We focus on importing .csv files, but with the skills acquired in this context you will face no difficulties in importing other data types as well."
  },
  {
    "objectID": "content/material/session09.html#lecture-slides",
    "href": "content/material/session09.html#lecture-slides",
    "title": "ğŸ—“ï¸ Session 9: Importing data",
    "section": "ğŸ‘¨â€ğŸ« Lecture Slides",
    "text": "ğŸ‘¨â€ğŸ« Lecture Slides\nEither click on the slide area below or click here to download the slides.\n\n  \n\n\nData for the exercises"
  },
  {
    "objectID": "content/material/session09.html#lecture-videos",
    "href": "content/material/session09.html#lecture-videos",
    "title": "ğŸ—“ï¸ Session 9: Importing data",
    "section": "ğŸ¥ Lecture videos",
    "text": "ğŸ¥ Lecture videos\nAll the videos are available via this playlist.\n\n\n\n\n\n\nExpand to access the videos directly"
  },
  {
    "objectID": "content/material/session09.html#mandatory-reading",
    "href": "content/material/session09.html#mandatory-reading",
    "title": "ğŸ—“ï¸ Session 9: Importing data",
    "section": "ğŸ“š Mandatory Reading",
    "text": "ğŸ“š Mandatory Reading\n\nThe tutorial Importing and exporting data using data.table"
  },
  {
    "objectID": "content/material/session09.html#further-reading",
    "href": "content/material/session09.html#further-reading",
    "title": "ğŸ—“ï¸ Session 9: Importing data",
    "section": "Further Reading",
    "text": "Further Reading\nTBA"
  },
  {
    "objectID": "content/material/session09.html#coursework",
    "href": "content/material/session09.html#coursework",
    "title": "ğŸ—“ï¸ Session 9: Importing data",
    "section": "âœï¸ Coursework",
    "text": "âœï¸ Coursework\n\nDo the exercises ProjectOrga from the DataScienceExercises package\n\n\n\n\n\n\n\nQuick code for starting the exercises\n\n\n\n\n\n\nlearnr::run_tutorial(\n  name = \"ProjectOrga\", \n  package = \"DataScienceExercises\", \n  shiny_args=list(\"launch.browser\"=TRUE))"
  },
  {
    "objectID": "content/material/session10.html",
    "href": "content/material/session10.html",
    "title": "ğŸ—“ï¸ Session 10: Data preparation",
    "section": "",
    "text": "In this session you learn how to turn your raw data into a state such that you can work with it. Luckily, there is one particular form for our data that represents the common starting point for all further operations, such as visualization or modelling. This form is called tidy data. And the goal of this session is to equip you with the tools that you need to turn the often messy raw data into tidy data. These skills are important because they make you independent: you will be able to prepare any data you find or create yourself such that you can further process it, and you will not rely on others to provide you data in a particular form."
  },
  {
    "objectID": "content/material/session10.html#lecture-slides",
    "href": "content/material/session10.html#lecture-slides",
    "title": "ğŸ—“ï¸ Session 10: Data preparation",
    "section": "ğŸ‘¨â€ğŸ« Lecture Slides",
    "text": "ğŸ‘¨â€ğŸ« Lecture Slides\nEither click on the slide area below or click here to download the slides.\n\n  \n\n\n\n\n\n\n\nData and solutions to the intermediate exercises\n\n\n\n\n\n\nData used in the video\nData for exercises"
  },
  {
    "objectID": "content/material/session10.html#lecture-videos",
    "href": "content/material/session10.html#lecture-videos",
    "title": "ğŸ—“ï¸ Session 10: Data preparation",
    "section": "ğŸ¥ Lecture videos",
    "text": "ğŸ¥ Lecture videos\nAll the videos are available via this playlist.\n\n\n\n\n\n\nExpand to access the videos directly\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSolutions to the intermediate exercises"
  },
  {
    "objectID": "content/material/session10.html#mandatory-reading",
    "href": "content/material/session10.html#mandatory-reading",
    "title": "ğŸ—“ï¸ Session 10: Data preparation",
    "section": "ğŸ“š Mandatory Reading",
    "text": "ğŸ“š Mandatory Reading\n\nThe tutorial Data preparation\nChapter 5 in Wickham et al. (2023)."
  },
  {
    "objectID": "content/material/session10.html#further-reading",
    "href": "content/material/session10.html#further-reading",
    "title": "ğŸ—“ï¸ Session 10: Data preparation",
    "section": "Further Reading",
    "text": "Further Reading\n\nThe help page for the selection helpers, which facilitate the selection of particular columns.\nChapter 13 in Wickham et al. (2023).\nChapter 14 in Wickham et al. (2023).\nWickham (2014) on the concept of â€˜tidy dataâ€™ (see the Github repo for reproduction of the paper)"
  },
  {
    "objectID": "content/material/session10.html#coursework",
    "href": "content/material/session10.html#coursework",
    "title": "ğŸ—“ï¸ Session 10: Data preparation",
    "section": "âœï¸ Coursework",
    "text": "âœï¸ Coursework\n\nDo the exercises Wrangling1 from the DataScienceExercises package\n\n\n\n\n\n\n\nQuick code for starting the exercises\n\n\n\n\n\n\nlearnr::run_tutorial(\n  name = \"Wrangling1\", \n  package = \"DataScienceExercises\", \n  shiny_args=list(\"launch.browser\"=TRUE))\n\n\n\n\n\nDownload data about the CO2 emissions for some countries of your choice from the World Bank website for the years 2000 to 2020. Set up an R project, save the data, import it, and make a line graph.\n\nZIP file with a possible solution1\n\nIf you want more exercises on the challenge of making data longer/wider, you can do the exercises Wrangling2 from the DataScienceExercises package\n\n\n\n\n\n\n\nQuick code for starting the exercises\n\n\n\n\n\n\nlearnr::run_tutorial(\n  name = \"Wrangling2\", \n  package = \"DataScienceExercises\", \n  shiny_args=list(\"launch.browser\"=TRUE))"
  },
  {
    "objectID": "content/material/session10.html#footnotes",
    "href": "content/material/session10.html#footnotes",
    "title": "ğŸ—“ï¸ Session 10: Data preparation",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nYou can ignore the make_co2_data.R for now and only look at make_co2_plot.R.â†©ï¸"
  },
  {
    "objectID": "content/tutorials/data-wrangling/index.html",
    "href": "content/tutorials/data-wrangling/index.html",
    "title": "Data preparation",
    "section": "",
    "text": "library(dplyr)\nlibrary(tidyr)\nlibrary(data.table)\nlibrary(here)\n\nThe data sets used in these notes are available from the course homepage:\n\nwrangling_data_raw.csv (data_raw)\nwrangling_data_raw_long.csv (data_raw_long)\nwrangling_data_final_expl.csv (data_final_expl)\nwrangling_gini_join.csv (gini_join)\nwrangling_gdp_join.csv (gdp_join)\n\nThe brackets show the names of the data sets used below."
  },
  {
    "objectID": "content/tutorials/data-wrangling/index.html#wide-and-long-format-definition",
    "href": "content/tutorials/data-wrangling/index.html#wide-and-long-format-definition",
    "title": "Data preparation",
    "section": "Wide and long format: definition",
    "text": "Wide and long format: definition\nThere is no strict definition for wide and long data. Rather, the two should be understood as relative descriptions of data, meaning that it is more straightforward to speak of a data set that is longer relative to another one, rather than a long data set per se.\nHere is an example for a rather long data set:\n\n\n   country  year variable    value\n    &lt;char&gt; &lt;int&gt;   &lt;char&gt;    &lt;num&gt;\n1: Germany  2017    unemp     3.75\n2: Germany  2017      gdp 53071.46\n3: Germany  2018    unemp     3.38\n4: Germany  2018      gdp 53431.39\n5:  Greece  2017    unemp    21.49\n6:  Greece  2017      gdp 28604.86\n7:  Greece  2018    unemp    19.29\n8:  Greece  2018      gdp 29141.17\n\n\nHere, we have one column identifying the variable, the value of which is stored in a separate column. This means that the data is relatively â€˜longâ€™ in the sense of having many rows. At the same time, it is relatively â€˜narrowâ€™ in the sense of not having too many columns since the variable identifier is kept in a single column.\nContrast this with an example for a rather wide data set, where each variable has its own column:\n\n\n   country  year unemp      gdp\n    &lt;char&gt; &lt;int&gt; &lt;num&gt;    &lt;num&gt;\n1: Germany  2017  3.75 53071.46\n2: Germany  2018  3.38 53431.39\n3:  Greece  2017 21.49 28604.86\n4:  Greece  2018 19.29 29141.17\n\n\nWhile the number of columns remains the same, the data set has relatively more columns as compared to the rows. At the same time, it tends to be shorter in the sense of having fewer rows.1\nWhile the long format is often easier to read and preferable when communicating data to humans, making data tidy often involves the task of making data â€˜longerâ€™."
  },
  {
    "objectID": "content/tutorials/data-wrangling/index.html#transforming-long-data-into-wide-data",
    "href": "content/tutorials/data-wrangling/index.html#transforming-long-data-into-wide-data",
    "title": "Data preparation",
    "section": "Transforming long data into wide data",
    "text": "Transforming long data into wide data\nTo make data wider we use the function tidyr::pivor_wider().\nAssume that we start with our long data set introduced above and that this data set is bound to the name data_raw_long.\n\ndplyr::glimpse(data_raw_long)\n\nRows: 8\nColumns: 4\n$ country  &lt;chr&gt; \"Germany\", \"Germany\", \"Germany\", \"Germany\", \"Greece\", \"Greeceâ€¦\n$ year     &lt;int&gt; 2017, 2017, 2018, 2018, 2017, 2017, 2018, 2018\n$ variable &lt;chr&gt; \"unemp\", \"gdp\", \"unemp\", \"gdp\", \"unemp\", \"gdp\", \"unemp\", \"gdp\"\n$ value    &lt;dbl&gt; 3.75, 53071.46, 3.38, 53431.39, 21.49, 28604.86, 19.29, 29141â€¦\n\n\nWe will now use tidyr::pivor_wider() to make this data set wider. The most important arguments of this function are as follows:2\n\ndata is the first argument and refers to the name of the data set to be considered\nnames_from denotes the column that includes the names of the new columns\nvalues_from denotes the column that includes the values to be allocated in the newly created cells\n\nIn the present case, the call would look like the following:\n\ndata_raw_wide &lt;- tidyr::pivot_wider(\n  data = data_raw_long, \n  names_from = \"variable\", \n  values_from = \"value\")\ndata_raw_wide\n\n# A tibble: 4 Ã— 4\n  country  year unemp    gdp\n  &lt;chr&gt;   &lt;int&gt; &lt;dbl&gt;  &lt;dbl&gt;\n1 Germany  2017  3.75 53071.\n2 Germany  2018  3.38 53431.\n3 Greece   2017 21.5  28605.\n4 Greece   2018 19.3  29141."
  },
  {
    "objectID": "content/tutorials/data-wrangling/index.html#transforming-wide-data-into-long-data",
    "href": "content/tutorials/data-wrangling/index.html#transforming-wide-data-into-long-data",
    "title": "Data preparation",
    "section": "Transforming wide data into long data",
    "text": "Transforming wide data into long data\nAssume we want to take the data set data_raw_wide and re-create the original long version. To achieve this we can use tidyr::pivot_longer(). Again, lets have a look at the most important arguments:3\n\ndata is the first argument and refers to the name of the data set to be considered\ncols denotes the columns that should be transformed into the longer format\nnames_to denotes the column that includes the names of the new columns\nvalues_to denotes the column that includes the values to be allocated in the newly created cells\n\nThe arguments names_to and values_to are not strictly necessary since they have useful default values, but its usually nicer to be explicit.\nWhen specifying the argument cols you have several possibilities. The simplest variant is to pass a character vector with the column names. But note that you can save a lot of writing by using so called selection helpers, a very useful tool we will learn about later.\nIn our case this amounts to:\n\ndata_raw_long &lt;- tidyr::pivot_longer(\n  data = data_raw_wide, \n  cols = c(\"unemp\", \"gdp\"), \n  names_to = \"indicator\", \n  values_to = \"values\")\ndata_raw_long\n\n# A tibble: 8 Ã— 4\n  country  year indicator   values\n  &lt;chr&gt;   &lt;int&gt; &lt;chr&gt;        &lt;dbl&gt;\n1 Germany  2017 unemp         3.75\n2 Germany  2017 gdp       53071.  \n3 Germany  2018 unemp         3.38\n4 Germany  2018 gdp       53431.  \n5 Greece   2017 unemp        21.5 \n6 Greece   2017 gdp       28605.  \n7 Greece   2018 unemp        19.3 \n8 Greece   2018 gdp       29141."
  },
  {
    "objectID": "content/tutorials/data-wrangling/index.html#creating-or-manipulating-variables",
    "href": "content/tutorials/data-wrangling/index.html#creating-or-manipulating-variables",
    "title": "Data preparation",
    "section": "Creating or manipulating variables",
    "text": "Creating or manipulating variables\nThe function dplyr::mutate() is used both for manipulating existing columns as well as creating new columns. In the first case the name of the column that the result of dplyr::mutate() is written into already exists, in the second case we just use a new name.\nConsider the following data set with the unemployment rate as an example:\n\ndata_unemp\n\n# A tibble: 2 Ã— 3\n   year Germany Greece\n  &lt;int&gt;   &lt;dbl&gt;  &lt;dbl&gt;\n1  2017    3.75   21.5\n2  2018    3.38   19.3\n\n\nAssume we want to express the percentage values via decimal numbers and, to this end, divide the values in the columns Germany and Greece by 100. We can use dplyr::mutate() to achieve this:\n\ndata_unemp %&gt;%\n  dplyr::mutate(\n    Germany = Germany/100,\n    Greece = Greece/100\n  )\n\n# A tibble: 2 Ã— 3\n   year Germany Greece\n  &lt;int&gt;   &lt;dbl&gt;  &lt;dbl&gt;\n1  2017  0.0375  0.215\n2  2018  0.0338  0.193\n\n\nBut we could use basically the same code to create a new column. Assume, for instance, we want a new column containing the difference between the unemployment rates:\n\ndata_unemp %&gt;%\n  dplyr::mutate(\n    Difference = Greece - Germany\n  )\n\n# A tibble: 2 Ã— 4\n   year Germany Greece Difference\n  &lt;int&gt;   &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt;\n1  2017    3.75   21.5       17.7\n2  2018    3.38   19.3       15.9\n\n\nThe only difference here was that the left-hand-side name of the column to be manipulated did not exist before!"
  },
  {
    "objectID": "content/tutorials/data-wrangling/index.html#filtering-rows",
    "href": "content/tutorials/data-wrangling/index.html#filtering-rows",
    "title": "Data preparation",
    "section": "Filtering rows",
    "text": "Filtering rows\nThe function dplyr::filter() can be used to filter rows according to certain conditions. The conditions must evaluate for each cell entry to either TRUE or FALSE, and only those rows for which they evaluate to TRUE remain in the data set. Often, the conditions are specified via logical operators, which were already covered in the tutorial on vector types.\nAs always, the first argument to dplyr::filter() is data, i.e.Â the data set on which you want to operate. Then follow an arbitrary number of logical conditions on the different columns of the data set on question.\nAssume we want to take the previously defined data set data_raw_long\n\ndata_raw_long\n\n# A tibble: 8 Ã— 4\n  country  year indicator   values\n  &lt;chr&gt;   &lt;int&gt; &lt;chr&gt;        &lt;dbl&gt;\n1 Germany  2017 unemp         3.75\n2 Germany  2017 gdp       53071.  \n3 Germany  2018 unemp         3.38\n4 Germany  2018 gdp       53431.  \n5 Greece   2017 unemp        21.5 \n6 Greece   2017 gdp       28605.  \n7 Greece   2018 unemp        19.3 \n8 Greece   2018 gdp       29141.  \n\n\nand only want to keep data on GDP:\n\ndata_raw_long %&gt;%\n  dplyr::filter(indicator==\"gdp\")\n\n# A tibble: 4 Ã— 4\n  country  year indicator values\n  &lt;chr&gt;   &lt;int&gt; &lt;chr&gt;      &lt;dbl&gt;\n1 Germany  2017 gdp       53071.\n2 Germany  2018 gdp       53431.\n3 Greece   2017 gdp       28605.\n4 Greece   2018 gdp       29141.\n\n\nYou may also combine more than one condition in one call to dplyr::filter(). If you also want to filter by values and only keep those rows where the value is below 50.000:\n\ndata_raw_long %&gt;%\n  dplyr::filter(\n    indicator==\"gdp\",\n    values &lt; 50000)\n\n# A tibble: 2 Ã— 4\n  country  year indicator values\n  &lt;chr&gt;   &lt;int&gt; &lt;chr&gt;      &lt;dbl&gt;\n1 Greece   2017 gdp       28605.\n2 Greece   2018 gdp       29141."
  },
  {
    "objectID": "content/tutorials/data-wrangling/index.html#selecting-columns",
    "href": "content/tutorials/data-wrangling/index.html#selecting-columns",
    "title": "Data preparation",
    "section": "Selecting columns",
    "text": "Selecting columns\nWhen you only want to keep certain columns we speak of selecting (rather than filtering) columns. This is done - surprise - via the function Â´dplyr::select()`.\nThere are different ways for selecting columns. In any case, the first argument is, again, data, i.e.Â the data set considered. In the present case, we will refer to data_raw:\n\ndata_raw\n\n   country  year unemp      gdp\n    &lt;char&gt; &lt;int&gt; &lt;num&gt;    &lt;num&gt;\n1: Germany  2017  3.75 53071.46\n2: Germany  2018  3.38 53431.39\n3:  Greece  2017 21.49 28604.86\n4:  Greece  2018 19.29 29141.17\n\n\nThen we can now select columns using one of the following two options. First, you may refer to columns via their name:\n\ndata_raw %&gt;%\n  dplyr::select(country, year, unemp)\n\n   country  year unemp\n    &lt;char&gt; &lt;int&gt; &lt;num&gt;\n1: Germany  2017  3.75\n2: Germany  2018  3.38\n3:  Greece  2017 21.49\n4:  Greece  2018 19.29\n\n\nBut this is often error-prone. Thus, it is usually better to refer to the columns via selection helpers, which is also the most flexible version. While we will learn about more selection helpers later, here we will mainly use dplyr::all_of(), which accepts a character vector of column names:\n\ndata_raw %&gt;%\n  dplyr::select(dplyr::all_of(c(\"country\", \"year\", \"gdp\")))\n\n   country  year      gdp\n    &lt;char&gt; &lt;int&gt;    &lt;num&gt;\n1: Germany  2017 53071.46\n2: Germany  2018 53431.39\n3:  Greece  2017 28604.86\n4:  Greece  2018 29141.17\n\n\n\nCaution: Do not forget the c()! Otherwise:\n\n\ndata_raw %&gt;%\n  dplyr::select(dplyr::all_of(\"country\", \"year\", \"gdp\"))\n\nError in `dplyr::select()`:\nâ„¹ In argument: `dplyr::all_of(\"country\", \"year\", \"gdp\")`.\nCaused by error in `dplyr::all_of()`:\n! unused arguments (\"year\", \"gdp\")\n\n\n\nIt is also possible to define the column vector first:\n\n\ncols2keep &lt;- c(\"country\", \"year\", \"gdp\")\ndata_raw %&gt;%\n  dplyr::select(dplyr::all_of(cols2keep))\n\n   country  year      gdp\n    &lt;char&gt; &lt;int&gt;    &lt;num&gt;\n1: Germany  2017 53071.46\n2: Germany  2018 53431.39\n3:  Greece  2017 28604.86\n4:  Greece  2018 29141.17\n\n\n\nSelection helpers allow you to specify the columns to be selected more generally. For instance, dplyr::ends_with() allows you to select all colums that end with a certain pattern:\n\n\ndata_raw %&gt;%\n  dplyr::select(dplyr::ends_with(\"p\"))\n\n   unemp      gdp\n   &lt;num&gt;    &lt;num&gt;\n1:  3.75 53071.46\n2:  3.38 53431.39\n3: 21.49 28604.86\n4: 19.29 29141.17\n\n\nIn any case, you can also specify the columns you want to drop. To this end, just add a - in front of the selection command:\n\ndata_raw %&gt;%\n  dplyr::select(-unemp, -gdp)\n\n   country  year\n    &lt;char&gt; &lt;int&gt;\n1: Germany  2017\n2: Germany  2018\n3:  Greece  2017\n4:  Greece  2018"
  },
  {
    "objectID": "content/tutorials/data-wrangling/index.html#merging-data-sets",
    "href": "content/tutorials/data-wrangling/index.html#merging-data-sets",
    "title": "Data preparation",
    "section": "Merging data sets",
    "text": "Merging data sets\nOften you need to obtain data from different sources. To merge all your data in one single data set, you need to use one of the *_join() functions of the dplyr-package. These functions all merge two data sets, but the way they do it is different. Below we illustrate the most common joins (so called mutating joins).4\nAs a guiding example we use the following two data sets:\nFirst, data on income inequality from the SWIID data base:\n\ngini_join\n\n   country  year  gini\n    &lt;char&gt; &lt;int&gt; &lt;num&gt;\n1:  Greece  2015  33.1\n2:  Greece  2017  32.2\n\n\nSecond, data on GDP per capita from the World Bank:\n\ngdp_join\n\n   country  year      gdp\n    &lt;char&gt; &lt;int&gt;    &lt;num&gt;\n1: Germany  2017 53071.46\n2: Germany  2018 53431.39\n3:  Greece  2017 28604.86\n4:  Greece  2018 29141.17\n\n\nWe will consider the behavior of the following four functions:\n\ndplyr::left_join()\ndplyr::right_join()\ndplyr::full_join()\ndplyr::inner_join()\n\nAll of them accept the following arguments:\n\nx and y: the two data sets to be merged\nby: a vector or a named vector indicating on which columns the data sets should be merged\n\nIts easier to understand their behavior if you contrast them directly with each other. First, dplyr::left_join() joins the data sets on those columns mentioned in by, but only keeps those rows for which x contains an observation:\n\ndplyr::left_join(x = gdp_join, y = gini_join, by = c(\"country\", \"year\"))\n\n   country  year      gdp  gini\n    &lt;char&gt; &lt;int&gt;    &lt;num&gt; &lt;num&gt;\n1: Germany  2017 53071.46    NA\n2: Germany  2018 53431.39    NA\n3:  Greece  2017 28604.86  32.2\n4:  Greece  2018 29141.17    NA\n\n\nThis might introduce NAs into the columns of y, but not of x. It is the other way around for dplyr::right_join(): it only keeps those rows for which y contains an observation:\n\ndplyr::right_join(x = gdp_join, y = gini_join, by = c(\"country\", \"year\"))\n\n   country  year      gdp  gini\n    &lt;char&gt; &lt;int&gt;    &lt;num&gt; &lt;num&gt;\n1:  Greece  2017 28604.86  32.2\n2:  Greece  2015       NA  33.1\n\n\ndplyr::inner_join() is the most restrictive option, keeping only those rows for which both x and y contain an observation (i.e.Â it never introduces NAs):\n\ndplyr::inner_join(x = gdp_join, y = gini_join, by = c(\"country\", \"year\"))\n\n   country  year      gdp  gini\n    &lt;char&gt; &lt;int&gt;    &lt;num&gt; &lt;num&gt;\n1:  Greece  2017 28604.86  32.2\n\n\nFinally, dplyr::full_join() contains all rows that occur at least in x or y, i.e.Â it might introduce NAs in both the columns of x and y:\n\ndplyr::full_join(x = gdp_join, y = gini_join, by = c(\"country\", \"year\"))\n\n   country  year      gdp  gini\n    &lt;char&gt; &lt;int&gt;    &lt;num&gt; &lt;num&gt;\n1: Germany  2017 53071.46    NA\n2: Germany  2018 53431.39    NA\n3:  Greece  2017 28604.86  32.2\n4:  Greece  2018 29141.17    NA\n5:  Greece  2015       NA  33.1\n\n\nTwo final remarks: first, the types of the columns on which you merge the data sets must be equal, otherwise R throws an error:\n\ngini_join &lt;- dplyr::mutate(gini_join, year=as.character(year))\ndplyr::left_join(x = gdp_join, y = gini_join, by = c(\"country\", \"year\"))\n\nError in `dplyr::left_join()`:\n! Can't join `x$year` with `y$year` due to incompatible types.\nâ„¹ `x$year` is a &lt;integer&gt;.\nâ„¹ `y$year` is a &lt;character&gt;.\n\n\nJust enforce the correct data type before merging:\n\ngini_join %&gt;% \n  dplyr::mutate(year=as.integer(year)) %&gt;%\n  dplyr::left_join(x = gdp_join, y = ., by = c(\"country\", \"year\"))\n\n   country  year      gdp  gini\n    &lt;char&gt; &lt;int&gt;    &lt;num&gt; &lt;num&gt;\n1: Germany  2017 53071.46    NA\n2: Germany  2018 53431.39    NA\n3:  Greece  2017 28604.86  32.2\n4:  Greece  2018 29141.17    NA\n\n\nSecond, you can also merge on columns with different names by passing named vectors to by:\n\ngini_join &lt;- gini_join %&gt;%\n  mutate(Year=as.double(year)) %&gt;%\n  select(-year)\ngini_join\n\n   country  gini  Year\n    &lt;char&gt; &lt;num&gt; &lt;num&gt;\n1:  Greece  33.1  2015\n2:  Greece  32.2  2017\n\n\nThen this does not work any more:\n\ndplyr::left_join(\n  x = gdp_join, y = gini_join, \n  by = c(\"country\", \"year\"))\n\nError in `dplyr::left_join()`:\n! Join columns in `y` must be present in the data.\nâœ– Problem with `year`.\n\n\nBut the named vector fixes it:\n\ndplyr::left_join(\n  x = gdp_join, y = gini_join, \n  by = c(\"country\", \"year\"=\"Year\"))\n\n   country  year      gdp  gini\n    &lt;char&gt; &lt;num&gt;    &lt;num&gt; &lt;num&gt;\n1: Germany  2017 53071.46    NA\n2: Germany  2018 53431.39    NA\n3:  Greece  2017 28604.86  32.2\n4:  Greece  2018 29141.17    NA"
  },
  {
    "objectID": "content/tutorials/data-wrangling/index.html#grouping-and-summarising-data",
    "href": "content/tutorials/data-wrangling/index.html#grouping-and-summarising-data",
    "title": "Data preparation",
    "section": "Grouping and summarising data",
    "text": "Grouping and summarising data\nThe final challenge we consider involves the application of two functions (at least in most cases): dplyr::group_by() and dplyr::summarize().\ndplyr::group_by() is usually used within pipes and groups a data set according to an arbitrary number of variables, each of which must refer to one (and only one) column. It produces a grouped data set:\n\ndata_raw_grouped &lt;- data_raw %&gt;%\n  dplyr::group_by(country)\ndata_raw_grouped\n\n# A tibble: 4 Ã— 4\n# Groups:   country [2]\n  country  year unemp    gdp\n  &lt;chr&gt;   &lt;int&gt; &lt;dbl&gt;  &lt;dbl&gt;\n1 Germany  2017  3.75 53071.\n2 Germany  2018  3.38 53431.\n3 Greece   2017 21.5  28605.\n4 Greece   2018 19.3  29141.\n\n\nAs you can see, the data set is now grouped by the variable country. We can specify the grouping variables the same way we selected columns in the context of dplyr::select() (see above).\nGrouped data sets are usually not interesting in itself. You can ungroup them via dplyr::ungroup():\n\ndata_raw_grouped %&gt;%\n  dplyr::ungroup()\n\n# A tibble: 4 Ã— 4\n  country  year unemp    gdp\n  &lt;chr&gt;   &lt;int&gt; &lt;dbl&gt;  &lt;dbl&gt;\n1 Germany  2017  3.75 53071.\n2 Germany  2018  3.38 53431.\n3 Greece   2017 21.5  28605.\n4 Greece   2018 19.3  29141.\n\n\nThey are most useful if used in conjunction with dplyr::summarise(), which summarizes variables. While it can be used without dplyr::group_by(), it is most useful if it is applied to grouped data sets: then it computes summary statistics for each group.\n\ndata_raw %&gt;%\n  summarise(\n    avg_gdp=mean(gdp)\n  )\n\n   avg_gdp\n1 41062.22\n\n\n\ndata_raw_grouped %&gt;%\n  summarise(\n    avg_gdp=mean(gdp)\n  )\n\n# A tibble: 2 Ã— 2\n  country avg_gdp\n  &lt;chr&gt;     &lt;dbl&gt;\n1 Germany  53251.\n2 Greece   28873.\n\n\nYou can also summarized more than one column:\n\ndata_raw_grouped %&gt;%\n  summarise(\n    avg_gdp=mean(gdp),\n    median_unemp=median(unemp)\n  )\n\n# A tibble: 2 Ã— 3\n  country avg_gdp median_unemp\n  &lt;chr&gt;     &lt;dbl&gt;        &lt;dbl&gt;\n1 Germany  53251.         3.57\n2 Greece   28873.        20.4 \n\n\nNote that dplyr::summarise() drops all columns that it is not asked to compute summary statistics for, except potential grouping variables. There are also some advanced features of the functions, which are explained in the official documentation."
  },
  {
    "objectID": "content/tutorials/data-wrangling/index.html#footnotes",
    "href": "content/tutorials/data-wrangling/index.html#footnotes",
    "title": "Data preparation",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nIf we had a data set with three instead of two variables, the wide data set would have the same number of rows, but more columns, i.e.Â it would be wider in an absolute sense as well.â†©ï¸\n The function allows for much more finetuning. You might read more about its argument in the help page of the function or the online documentation.â†©ï¸\n See the online documentation for a more complete description.â†©ï¸\n The other join types are filtering joins and nest joins. You find more information in the web, and more details on the underlying theory in chapter 13 of R4DS.â†©ï¸\nWe have not yet covered the function ifelse(). It contains a logical test as a first argument, and then two further arguments: one return value for the case in which the test returns TRUE, and one for which the test returns FALSE.â†©ï¸"
  },
  {
    "objectID": "content/tutorials/first-steps/index.html",
    "href": "content/tutorials/first-steps/index.html",
    "title": "First steps in R",
    "section": "",
    "text": "In this post we will learn about the basic syntax of R. The syntax basically refers to the grammatical rules you must adhere to when communicating with your computer in the language R: if you do not follow the right syntax, i.e.Â you â€˜speakâ€™ grammatically incorrect, your computer will not understand you and communicate this to you by throwing up an error message.\nTo learn about these important basics, the post follows the following structure:"
  },
  {
    "objectID": "content/tutorials/first-steps/index.html#footnotes",
    "href": "content/tutorials/first-steps/index.html#footnotes",
    "title": "First steps in R",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nIf you do not know what the console is, you should have a look at the lecture slides from the Material section again.â†©ï¸\nYou may try this out by typing 1:100 into your console and see what happens: this returns a vector of length 100, which certainly will contain some line breaks.â†©ï¸\nAgain, the use of scripts has been explained in the lecture, so have a look at the slides (or the R-Studio cheat sheet) in the Material section.â†©ï¸\nIn theory we can use &lt;- also the other way around: 2 + 3 -&gt; intermediate_result. At first sight this is more intuitive and respects the sequence of events: first, the result of 2 + 3 gets created, i.e.Â a new object gets defined. Then, this object gets the name intermediate_result. However, the code that results from such practice is usually much more difficult to read, so it is common practice to use &lt;- rather than -&gt;.â†©ï¸\nWickham and Bryan (2022) provide an excellent introduction to the development of R packagesâ†©ï¸\nPackages not released on this platform can also be installed directly from the repository they were published, e.g.Â Github. To this end, the package remotes must be installed first, then you can use functions such as install_github(). A short manual is provided here.â†©ï¸"
  },
  {
    "objectID": "content/tutorials/importing-exporting-data/index.html",
    "href": "content/tutorials/importing-exporting-data/index.html",
    "title": "Importing and exporting data",
    "section": "",
    "text": "Packages used in this tutorial:\nlibrary(here)\nlibrary(data.table)\nlibrary(dplyr)"
  },
  {
    "objectID": "content/tutorials/importing-exporting-data/index.html#specify-the-column-separator-using-sep-and-the-decimal-sign-using-dec",
    "href": "content/tutorials/importing-exporting-data/index.html#specify-the-column-separator-using-sep-and-the-decimal-sign-using-dec",
    "title": "Importing and exporting data",
    "section": "Specify the column separator using sep and the decimal sign using dec",
    "text": "Specify the column separator using sep and the decimal sign using dec\nWhile the example file above represents the widespread standard case in which columns are separated by a comma and the dot is used as the decimal sign, many files use other symbols. In Germany, for instance, it is very common to use ; as a separator for columns, and , as a decimal sign instead. Thus, the â€˜German versionâ€™ of our example from above would look like this:\niso2c;year;Exporte\nAT;2012;53,97\nAT;2013;53,44\nAT;2014;53,38\nSometimes, data.table::fread() detects such cases automatically and adjusts the values for the optional arguments implicitly. But it is always better to explicit and to specify decimal signs and column separators explicitly! This also increases the reading speed of data.table::fread(). To set them explicitly, we use the arguments sep and dec as follows:\n\nexp_data &lt;- data.table::fread(\n  file = file_path,\n  sep = \";\", \n  dec = \",\"\n  )\n\nAfter completing the function call we should always inspect the imported object to make sure everything went well. We might have a look at the first lines:\n\nexp_data &lt;- tibble::as_tibble(exp_data)\nhead(exp_data, n = 2)\n\n# A tibble: 2 Ã— 3\n  iso2c  year exports\n  &lt;chr&gt; &lt;int&gt;   &lt;dbl&gt;\n1 AT     2012    54.0\n2 AT     2013    53.4\n\n\nOr use dplyr::glimpse() or str():\n\nstr(exp_data)\n\ntibble [3 Ã— 3] (S3: tbl_df/tbl/data.frame)\n $ iso2c  : chr [1:3] \"AT\" \"AT\" \"AT\"\n $ year   : int [1:3] 2012 2013 2014\n $ exports: num [1:3] 54 53.4 53.4\n - attr(*, \".internal.selfref\")=&lt;externalptr&gt;"
  },
  {
    "objectID": "content/tutorials/importing-exporting-data/index.html#set-the-object-type-of-the-columns-using-colclasses",
    "href": "content/tutorials/importing-exporting-data/index.html#set-the-object-type-of-the-columns-using-colclasses",
    "title": "Importing and exporting data",
    "section": "Set the object type of the columns using colClasses",
    "text": "Set the object type of the columns using colClasses\nUsually, the automatic type recognition of data.table::fread() works quite well. This means that R chooses the right data type for each column automatically. Sometimes, however, this detection fails and you need to specify the column types manually. But even if the automatic recognition works, there are some good reasons for playing save and specify the column types yourself:\n\nYou will notice more easily if there is a problem with a column, e.g.Â if a word occurs in a column that consists exclusively of numbers. occurs. If you did not specify this column manually as double, data.table::fread() would simply interpret it silently as a character and you would later wonder later why you cannot calculate an average for the column;\nYour code will be more transparent and easier to read if one immediately knows what kind of data you are importing\nThe import process will be much faster if you provide the column types yourself and the function does not need to guess the types itself.\n\nOne situation where specifying column types yourself is extremely important is when a column contains numerical codes that might contain a leading zero, e.g.Â when the data contain HS product codes, such as here:\ncommoditycode,complexity\n0101,0.06\n0102,-0.49\n0103,0.51\n0104,-1.12\n0105,-0.17\nAssuming the file is called exp_data_hs.csv and also is stored in data/tidy/, we might try to import it using the default argument values:\n\nfile_path &lt;- here::here(\"data/tidy/exp_data_hs.csv\")\nexp_prod_data &lt;- data.table::fread(file = file_path)\nexp_prod_data &lt;- tibble::as_tibble(exp_prod_data)\nexp_prod_data\n\n\n\n# A tibble: 5 Ã— 2\n  commoditycode complexity\n          &lt;int&gt;      &lt;dbl&gt;\n1           101       0.06\n2           102      -0.49\n3           103       0.51\n4           104      -1.12\n5           105      -0.17\n\n\nAs you can see, data.table::fread() interpreted the column commoditycode as double. But since numbers do not have leading zeros, these are removed silently, meaning that R does not issue a warning message. This is dangerous and might come with serious misinterpretations later on. To avoid this, you must choose the column types yourself via the colClasses argument, by simply specifying a vector with the data types:\n\nfile_path &lt;- here::here(\"data/tidy/exp_data_hs.csv\")\nexp_prod_data &lt;- data.table::fread(\n  file = daten_pfad, colClasses = c(\"character\", \"double\")\n  )\ntibble::as_tibble(exp_prod_data)\n\n\n\n# A tibble: 5 Ã— 2\n  commoditycode complexity\n  &lt;chr&gt;              &lt;dbl&gt;\n1 0101                0.06\n2 0102               -0.49\n3 0103                0.51\n4 0104               -1.12\n5 0105               -0.17\n\n\nAs you can see, encoding the column commoditycode as character preserves the leading zeros and the correct product codes.\nFor data sets with many columns it is often tedious to specify column types one by one. Here it might be useful to use the function rep(): it saves space if, for instance, 6 subsequent columns are all of type double. In this case you may just write rep(\"double\" , 6)."
  },
  {
    "objectID": "content/tutorials/importing-exporting-data/index.html#specify-how-many-rows-should-be-readskipped-using-nrows-and-skip",
    "href": "content/tutorials/importing-exporting-data/index.html#specify-how-many-rows-should-be-readskipped-using-nrows-and-skip",
    "title": "Importing and exporting data",
    "section": "Specify how many rows should be read/skipped using nrows and skip",
    "text": "Specify how many rows should be read/skipped using nrows and skip\nKeep in mind that you can increase the reading speed of data.table::fread() considerably by manually specifying the columns types. At the same time, opening very large data files in R Studio or even a text editor can slow down your computer considerably.\nThus, it is advisable to read in the first 3-5 rows, inspect them, and then read in the whole data set with the right specification for colClasses.\nYou can load only the first \\(n\\) rows by using the argument nrows:\n\nexp_data &lt;- tibble::as_tibble(data.table::fread(\n  file = here::here(\"data/tidy/exp_data.csv\"), \n  nrows = 1)\n  )\nexp_data\n\n\n\n# A tibble: 1 Ã— 3\n  iso2c  year exports\n  &lt;chr&gt; &lt;int&gt;   &lt;dbl&gt;\n1 AT     2012    54.0\n\n\nIn other instances, you might also want to skip the first \\(n\\) rows. This is often the case if your file contains some general introductory header, which is placed before the actual data set. Such data with a header might look like this:\nThis is awesome data from 2012-2014\nIt was compiled be Claudius\nHe also added this useless header\niso2c,year,Exporte\nAT,2012,53.97\nAT,2013,53.44\nAT,2014,53.38\n\nIn this case, you definitely want to ignore the first three rows when importing the data set. Otherwise you will get hodgepodge:\n\nexp_data &lt;- data.table::fread(\n  file = here::here(\"data/tidy/exp_data_header.csv\")\n  )\ntibble::as_tibble(exp_data)\n\n\n\n# A tibble: 1 Ã— 6\n  V1    It    was   compiled be      Claudius\n  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;   &lt;chr&gt;   \n1 He    also  added this     useless header  \n\n\nTo ignore the first three rows just set skip to 3:\n\nexp_data &lt;- tibble::as_tibble(data.table::fread(\n  file = here::here(\"data/tidy/exp_data_header.csv\"), \n  skip = 3)\n  )\nexp_data\n\n\n\n# A tibble: 3 Ã— 3\n  iso2c  year Exporte\n  &lt;chr&gt; &lt;int&gt;   &lt;dbl&gt;\n1 AT     2012    54.0\n2 AT     2013    53.4\n3 AT     2014    53.4\n\n\nAgain, the automatic detection of fread() often works quite well when it comes to the identification of useless headers, but better be prepared to use skip whenever necessary."
  },
  {
    "objectID": "content/tutorials/importing-exporting-data/index.html#specify-columns-that-should-not-be-read-using-select-and-drop",
    "href": "content/tutorials/importing-exporting-data/index.html#specify-columns-that-should-not-be-read-using-select-and-drop",
    "title": "Importing and exporting data",
    "section": "Specify columns that should (not) be read using select and drop",
    "text": "Specify columns that should (not) be read using select and drop\nSometimes you only want to read in a certain selection of columns. This can also save a lot of time when working with large data sets. In the following example we only want to import the columns year and exports:\n\nexp_data &lt;- data.table::fread(\n  file = here::here(\"data/tidy/exp_data.csv\")\n  nrows = 1, \n  select = c(\"year\", \"Exporte\")\n  )\nexp_data &lt;- tibble::as_tibble(exp_data)\nexp_data\n\n\n\n# A tibble: 2 Ã— 2\n   year exports\n  &lt;int&gt;   &lt;dbl&gt;\n1  2012    54.0\n2  2013    53.4\n\n\nIf you want to manually specify column types, you can do so without using colClasses by passing a named vector to select:\n\nexp_data &lt;- data.table::fread(\n  file = here::here(\"data/tidy/exp_data.csv\")\n  nrows = 1, \n  select = c(\"year\"=\"double\", \"exports\"=\"double\")\n  )\nexp_data &lt;- tibble::as_tibble(exp_data)\nexp_data\n\n\n\n# A tibble: 2 Ã— 2\n   year exports\n  &lt;dbl&gt;   &lt;dbl&gt;\n1  2012    54.0\n2  2013    53.4\n\n\nAlternatively, we can also specify columns to be ignored via drop:\n\nexp_data &lt;- data.table::fread(\n  file = here::here(\"data/tidy/exp_data.csv\")\n  nrows = 1, \n  drop = \"iso2c\"\n  )\nexp_data &lt;- tibble::as_tibble(exp_data)\nexp_data\n\n\n\n# A tibble: 2 Ã— 2\n   year exports\n  &lt;int&gt;   &lt;dbl&gt;\n1  2012    54.0\n2  2013    53.4"
  },
  {
    "objectID": "content/tutorials/importing-exporting-data/index.html#footnotes",
    "href": "content/tutorials/importing-exporting-data/index.html#footnotes",
    "title": "Importing and exporting data",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nYou can also specify alternative arguments, such as cmd when you want to parse the input file using a command line command. But we will not cover such more advanced cases here.â†©ï¸"
  },
  {
    "objectID": "content/tutorials/installation/index.html",
    "href": "content/tutorials/installation/index.html",
    "title": "Installation of the necessary software",
    "section": "",
    "text": "During this course we will use the following software and services:\n\nR\nR-Studio\nGit\nGithub\nNetlify\n\nYou will need to install the software and register for these services on your own. While I offer an optional session for joint troubleshooting, it is absolutely necessary that you do your best to install the software on your own before that date. To this end, this document is meant to provide you with all the information needed. If you have questions, please use the Moodle forum. It is very unlikely that you are the only person having a particular problem. Maybe others can already help you out, and if not, all should benefit from the solution we find for your problem together.\nPlease also note that there is a separate tutorial on how to install the packages (a.k.a. R extensions) that we are going to use over the semester. Its best to continue with this tutorial on installing the required R packages directly after you have complete this one."
  },
  {
    "objectID": "content/tutorials/installation/index.html#install-r",
    "href": "content/tutorials/installation/index.html#install-r",
    "title": "Installation of the necessary software",
    "section": "Install R",
    "text": "Install R\nThe installation of R is very similar across operating systems (OS). The easiest way is to visit the R Homepage and to download the most recent version for your OS. In case you are using Mac OS and want to use Homebrew, its best to use this formula.\nImportant for Mac user: There are different versions of R for Intel chips, and Apple chips (M1, M2, etc.). It is very important that you install the correct version. If you are not sure whether your Mac contains a chip from Intel or Apple, click on the Apple symbol in the upper left of the screen, then click on About this Mac and you can see which processor your Mac is using in the new window. If you have an Apple chip, always install R for the so called arm64 architecture. Intel chip users must use the x86_64 architecture instead.\n\nOnly Windows: Install RTools\nIf you are using Windows, it is necessary to install RTools, which is required if you want to use packages written by others that are not officially released. To do so, simply visit the following website, download the installer, and install the software:\nWhen asked during the installation process, do not select the box for Add rtools to system PATH, but do select the box for Save version information to registry.\n\n\nOnly Mac: Command Line Developer Tools\nThe Command Line Developer Tools could be thought of as the Mac pendant to RTools. These allow you to build R packages from source (meaning, basically, you can use packages that are in early stages of distribution, or packages that are not released on the official R servers).\nThe easiest way to install them is to open the App Terminal, and then to type\nxcode-select --install\nand press Enter. Then a pop up window will open and allow you to install the software."
  },
  {
    "objectID": "content/tutorials/installation/index.html#update-r",
    "href": "content/tutorials/installation/index.html#update-r",
    "title": "Installation of the necessary software",
    "section": "Update R",
    "text": "Update R\nIn case R is already installed on your computer you should make sure that your version is more of less up to date. For our seminar you should use at least R version R 4.4.2. The version you are currently using is shown as soon as you start R.\nPlease note: if you installed R anew in the previous step, you do not need to update it. The information on updating R is mainly relevant for people who have installed R already some time ago.\n\nMacOS users\nFor MacOS users, the easiest route to update R is to just re-install the most current version from the R Homepage. Keep in mind that in this case you might need to re-install all previously installed packages. If you have a lot of packages installed that you want to keep, the following steps facilitates the re-installation process. First, save a list with all the packages you installed yourself. To this end type the following into the R console:1\npackage_overview &lt;- installed.packages()\npackage_names &lt;- as.vector(\n  package_overview[is.na(package_overview[,\"Priority\"]), 1])\nsave(package_names, file=\"r_packages.rda\")\nAfter re-installing R, you then need to load the file you previously saved and identify the missing packages. You can use the following code to do so if you are in the working directory in which you saved the file \"r_packages.rda\":\nload(\"r_packages.rda\")\npackages_new &lt;- installed.packages()\npackages_new_ &lt;- as.vector(packages_new[is.na(packages_new[,\"Priority\"]), 1])\nmissing_packages &lt;- setdiff(package_names, packages_new_)\ninstall.packages(missing_packages)\nupdate.packages()\n\n\nWindows users\nWindows users have a slightly more convenient route available to them: the installr package. It does not require you to re-install your packages. Just type the following code into your R console:2\ninstall.packages(\"installr\")\nlibrary(installr)\nupdateR(TRUE)\nFor more information see the package website.\n\n\nLinux users\nLinux users simply install R via their package manager. A quick search on Google should provide you with the information that are relevant for your particular Linux distribution. Updating is usually straightforward as well: just run the respective command from your package manager."
  },
  {
    "objectID": "content/tutorials/installation/index.html#r-studio",
    "href": "content/tutorials/installation/index.html#r-studio",
    "title": "Installation of the necessary software",
    "section": "R-Studio",
    "text": "R-Studio\nInstalling R-Studio is easy. The only thing you should keep in mind that you should install R first, and R-Studio second. So, after installing R got to the R-Studio download page and download the RStudio Desktop version for your OS according to the installation instructions provided.\nIf you are on Mac and you are using Homebrew you may use this formula.\nIf you want to update R-Studio, you just install it again. Please note that the minimal version for this seminar should be RStudio 2023.12.1+402, which is from late January 2024. You can check your version by clicking on RStudio in the upper left part of your screen when R-Studio is open. Then click on About RStudio."
  },
  {
    "objectID": "content/tutorials/installation/index.html#git",
    "href": "content/tutorials/installation/index.html#git",
    "title": "Installation of the necessary software",
    "section": "Git",
    "text": "Git\nInstalling Git is straightforward, but the right approach depends on your OS.\n\nMacOS\nOn MacOS you should install Git as part of the Command Line Developer Tools, which themselves are part of XCode (see above). Its easiest to run the following command from your Terminal:3\ngit --version\nIf you get an output such as git version 2.34.1 you already installed you need. If not, you will be asked to install the respective software packages (see above).\n\n\nWindows\nOn Windows you download Git for Windows from the official Webpage, which also provides you with all the relevant instructions.\n\n\nLinux\nOn Linux use you package manager. In most cases the name of the relevant package is git-all, so on Ubuntu, for instance, you would install Git via sudo apt install git-all."
  },
  {
    "objectID": "content/tutorials/installation/index.html#install-quarto",
    "href": "content/tutorials/installation/index.html#install-quarto",
    "title": "Installation of the necessary software",
    "section": "Install Quarto",
    "text": "Install Quarto\nQuarto allows you to write text and R code within one document. This is very useful in many instances, and allows you to create a wide variety of nicely looking and practically appealing outputs, including apps, websites, statistical reports, and much more. To install Quarto just follow the instructions from this webpage."
  },
  {
    "objectID": "content/tutorials/installation/index.html#github",
    "href": "content/tutorials/installation/index.html#github",
    "title": "Installation of the necessary software",
    "section": "Github",
    "text": "Github\nThis is easy. Just visit https://github.com/ and sign up using your email account."
  },
  {
    "objectID": "content/tutorials/installation/index.html#netlify",
    "href": "content/tutorials/installation/index.html#netlify",
    "title": "Installation of the necessary software",
    "section": "Netlify",
    "text": "Netlify\nThis is easy as well. Visit https://www.netlify.com/ and click on Sign up in the upper right of the webpage. You can now either create a Netlify account by clicking on Email and register a new email address, or you can link Netlify to one of the other accounts you might already have. I personally, for instance, linked Netlify to my Github account."
  },
  {
    "objectID": "content/tutorials/installation/index.html#footnotes",
    "href": "content/tutorials/installation/index.html#footnotes",
    "title": "Installation of the necessary software",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nIf you do not yet know what the R console is donâ€™t worry. You will learn this during the course. But for now it would then be better to update R by just re-installing it.â†©ï¸\nIf you do not yet know what the R console is donâ€™t worry. You will learn this during the course. But for now it would then be better to update R by just re-installing it.â†©ï¸\nBy this I mean that you first open the app Terminal and then enter the commend into the window that has opened, and then press Enter.â†©ï¸"
  },
  {
    "objectID": "content/tutorials/installing-packages/index.html",
    "href": "content/tutorials/installing-packages/index.html",
    "title": "Installing R packages",
    "section": "",
    "text": "After installing R and R-Studio, you still need to install a number of so called R packages. We will learn more about what packages are and how to use them later. Nevertheless, I strongly recommend you to install already all the packages you will need over the following semester already now. This way you make sure that everything is working now, and you save yourself from trouble during the semester. Moreover, installing these packages is necessary to do the exercises provided after each session.\nTo install packages, a stable internet connection is required. Then, proceed as follows:\n\nDownload the script install_packages_script.R and save it in a directory of your choice\nOpen the file install_packages_script.R in R-Studio. To this end, right-click on the file and select Open with, and then choose R-Studio.\nAdjust the first line of the script to the OS you are using. For instance, when you are using a Mac the file should look like this:\n\n\n\n\n\n\n\n\n\n\n\n\nSelect lines 1-52 and click on the button Run (the screenshot only shows the lines 42-52, the previous lines are also selected):\n\n\n\n\n\n\n\nCheck if the package here was installed. You will get the respective message in the console:\n\n\n\n\n\n\nIf you encounter any problems, please make a screenshot and post it in the Moodle forum.\n\nSelect the rest of the scrip and run it as you did with the first lines. If you get the following message everything worked well and all packages were installed successfully:\n\n\n\n\n\n\nIf not, please post the file InstallationLog.txt and a screenshot with an error into the Moodle forum.\nNote: maybe you will see the following message during the installation process (possible multiple times):\n\n\n\n\n\nI recommend to type No and press enter. If, for any reason, the installation process is not successful you might run the installation commands again and try responding with Yes, this might sometimes fix the problem."
  },
  {
    "objectID": "content/tutorials/installing-packages/index.html#a-common-problem-when-installing-tinytex-on-a-mac",
    "href": "content/tutorials/installing-packages/index.html#a-common-problem-when-installing-tinytex-on-a-mac",
    "title": "Installing R packages",
    "section": "A common problem when installing tinytex on a Mac",
    "text": "A common problem when installing tinytex on a Mac\nThe following hints should be helpful if after the attempted installation of tinytex you see either one of these error messages:\n\n\n\n\n\n\n\n\n\n\nIn this case, execute the following comment in your R console within R-Studio:\n\ntinytex::install_tinytex(force = TRUE)\n\nThen close R-Studio and restart your computer. If test_pdf.qmd still cannot be compiled after this, please open your Mac Terminal (via the app Terminal) and enter the following commands:\nsudo chown -R `whoami`:admin /usr/local/bin\n\n~/Library/TinyTeX/bin/x86_64-darwin/tlmgr path add\nThen install tinytex again as described above, restart your computer, and try to compile test_pdf.qmd again."
  },
  {
    "objectID": "content/tutorials/obj-types-i-functions/index.html",
    "href": "content/tutorials/obj-types-i-functions/index.html",
    "title": "Fundamental object types in R I: Functions",
    "section": "",
    "text": "We already learned that everything in R that exists is an object. You most likely already noted that there are different types of objects: 2, for instance, was a number, but assign was a function.1 As you might have guessed, there are many more types of objects. To understand the fundamental object types in R is an essential prerequisite to master more complicated programming challenges than those we have encountered so far. Thus, this post is among those that will introduce you to the most important object types that you will encounter in R.\nThese data types are summarized in the following figure:\n\n\n\n\n\nThis post will be about functions. Different types of vectors are covered in the upcoming posts."
  },
  {
    "objectID": "content/tutorials/obj-types-i-functions/index.html#footnotes",
    "href": "content/tutorials/obj-types-i-functions/index.html#footnotes",
    "title": "Fundamental object types in R I: Functions",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nIn fact, we will learn below that 2 is not really a number, but a vector or length 1. Only in a next step, 2 counts as a â€˜numberâ€™, or, more precisely as a â€˜doubleâ€™.â†©ï¸\nUsing return is, strictly speaking, not necessary, but I always use it for the sake of readability and transparency. An interesting debate about whether you should use return or not can be found here.â†©ï¸\nOr, as the well-known R developer Hadley Wickham puts it: â€œYou are always coorpering with at least one other person: future-you.â€â†©ï¸"
  },
  {
    "objectID": "content/tutorials/obj-types-ii-vectors/index.html",
    "href": "content/tutorials/obj-types-ii-vectors/index.html",
    "title": "Fundamental object types in R II: Vectors",
    "section": "",
    "text": "We already learned that everything in R that exists is an object. You most likely noted that there are different types of objects: 2, for instance, was a number, but assign was a function.1 As you might have guessed, there are many more types of objects. To understand the fundamental object types in R is an essential prerequisite to master more complicated programming challenges than those we have encountered so far. Thus, this post is among those that will introduce you to the most important object types that you will encounter in R.\nThese data types are summarized in the following figure:\n\n\n\n\n\nThis post will be about the most common types of vectors. See the previous post for a treatment of functions, and the upcoming one for more advanced types of vectors, such as factor, matrix, and data.frame."
  },
  {
    "objectID": "content/tutorials/obj-types-ii-vectors/index.html#atomic-vectors",
    "href": "content/tutorials/obj-types-ii-vectors/index.html#atomic-vectors",
    "title": "Fundamental object types in R II: Vectors",
    "section": "Atomic vectors",
    "text": "Atomic vectors\nThis makes it easy to classify atomic vectors in more detail: we usually say that the type of atomic vector is the type of the object it encompasses. Four major types of atomic vectors in this sense exist:\n\nlogical (logical values): there are only two relevant logical values: TRUE und FALSE3\ninteger (whole numbers): this type should be self-explanatory. Less intuitive is the rule that in order to define an integer in R you need to type the number followed by the letter L such that R interprets the number as an integer.4 Examples are 1L, -400L or 10L.\n\ndouble (decimal numbers): these should be self-explanatory as well. Examples are 1.5, 0.0, or -500.32.\nWhole and decimal numbers are often summarized in the category numeric. However, the use of numeric is almost always confusing, and many functions show counter-intuitive behavior when this category is used. I recommend you to never use it.\ncharacter (words): these can contain all kinds of tokens and are characterized by the fact that they always start and end with \" (or '). Examples would be \"Hello\", \"500\" or \"1_2_Three\".\n\nAs indicated above, an atomic vector only comprises elements of the same type. In this context, we should mention, however, the at first sight â€˜strangeâ€™ data type NA, which denotes a missing value:5 whenever an element of a vector is missing, e.g.Â when the vector is used to store observations of subjects that have participated in an experiment, and for some subjects the observation is missing, we will use NA.6\n\nTesting and coercing types\nIn the following we will study the different types of atomic vectors and their typical behavior in more detail. But before doing so we should introduce the function typeof(): it helps us to identify the type of an object in the first place. To see how, lets call the function with the object (or the name of the object) we are interested about:\n\ntypeof(2L)\n\n[1] \"integer\"\n\n\n\nx &lt;- 22.0\ntypeof(x)\n\n[1] \"double\"\n\n\nThere is also a family of functions that allows us to test whether an object is actual of a certain type or not. The general syntax here is is.*(). For instance:\n\nx &lt;- 1.0\nis.integer(x)\n\n[1] FALSE\n\n\n\nis.double(x)\n\n[1] TRUE\n\n\nThis function always returns an object of type logical:\n\ny &lt;- is.double(x)\ntypeof(y)\n\n[1] \"logical\"\n\n\nWe can also try to transform objects from one type into another. We call this process â€˜coercionâ€™ an the general syntax is as.*()*. For instance:\n\nx &lt;- \"2\"\nprint(\n  typeof(x)\n)\n\n[1] \"character\"\n\nx &lt;- as.double(x)\nprint(\n  typeof(x)\n)\n\n[1] \"double\"\n\n\nSuch a transformation is, however, not always possible:\n\nas.double(\"Hello\")\n\nWarning: NAs introduced by coercion\n\n\n[1] NA\n\n\nSince R does not know how to turn the word â€˜Helloâ€™ into a decimal number, it transforms it into a â€˜missing valueâ€™ - NA.\nFor the basic types discussed above there is a logical hierarchy of feasible transformations: logical â†’ integer â†’ double â†’ character, meaning that you can always transform a decimal number into a word, but not vice versa.\n\nTransgression: Why change the types of objects anyway? Data types are extremely important for a programming language because otherwise it would remain unclear how mathematical operations could be applied to different objects such as numbers or words. You will transform objects yourself especially when you want to use a certain operation that is only defined for a certain type of object, and the object you are dealing with has been stored as a different type. This can happen, for example, when you read in data or translate words into numerical values yourself. If unexpected errors occur in your code with cryptic error messages, it is always a good idea to check the types of the objects used and transform them if necessary.\n\n\nx &lt;- 2\ny &lt;- as.character(x)\nprint(y)\n\n[1] \"2\"\n\nz &lt;- as.double(y) # This works\nprint(z)\n\n[1] 2\n\nk &lt;- as.double(\"Hallo\") # This does not work\n\nWarning: NAs introduced by coercion\n\nprint(k)\n\n[1] NA\n\n\nWhen transforming logical values, TRUE counts as 1 and FALSE as 0, a fact that will come in handy later on:\n\nx &lt;- TRUE\nas.integer(x)\n\n[1] 1\n\n\n\ny &lt;- FALSE\nas.integer(y)\n\n[1] 0\n\n\nSince it is not always clear when R issues a warning for transformations that are incompatible with the hierarchy just introduced and when it does not, you should always be cautious!\nMoreover, transformations might change the properties of the transformed objects implicitly in unexpected ways. For instance, a transformation from a decimal number to a whole number can lead to unexpected rounding behavior:\n\nx &lt;- 1.99\nas.integer(x)\n\n[1] 1\n\n\nAnother example is the following:\n\nz &lt;- as.logical(99)\nprint(z)\n\n[1] TRUE\n\n\nSuch implicit changes of the object properties do not necessary come with a warning message, so one should always be careful when transforming objects!\nIn many cases, functions do the necessary transformations of their arguments automatically. In most cases this is very practical:\n\nx &lt;- 1L # Integer\ny &lt;- 2.0 # Double\nz &lt;- x + y\ntypeof(z)\n\n[1] \"double\"\n\n\nBut it can be dangerous in some cases as well.\nWhen adding up logical values they are transformed to numbers:\n\nx &lt;- TRUE\ny &lt;- FALSE\nz &lt;- x + y # TRUE counts as 1, FALSE as 0\nprint(z) \n\n[1] 1\n\n\nThis is useful if you want to know, for instance, how many elements of a vector meet a certain logical criterion:\n\nx &lt;- c(1,2,3,4,5)\nsum(x &gt; 3)\n\n[1] 2\n\n\nIn all these cases it is very important to stay informed about the types of objects you are dealing with. To help you out, the following table contains an overview over the most important transformation and test functions:\n\n\n\nType\nTest\nTransformation\n\n\n\n\nlogical\nis.logical\nas.logical\n\n\ndouble\nis.double\nas.double\n\n\ninteger\nis.integer\nas.integer\n\n\ncharacter\nis.character\nas.character\n\n\nfunction\nis.function\nas.function\n\n\nNA\nis.na\nNA\n\n\nNULL\nis.null\nas.null\n\n\n\nA final remark on scalars: with scalar we usually refer to â€˜single numbersâ€™, such as 2. There is no such concept in R: 2 is a vector with one element (or: of length 1). Thus, we do not distinguish the type of a vector with or more than one elements.\nNote: As you might have guessed already, we use the function c() to create longer vectors:\n\nx &lt;- c(1, 2, 3)\nx\n\n[1] 1 2 3\n\n\nWe can also use this function to concatenate vectors:\n\nx &lt;- 1:3 # Shortcut for: x &lt;- c(1, 2, 3)\ny &lt;- 4:6\nz &lt;- c(x, y)\nz\n\n[1] 1 2 3 4 5 6\n\n\nSince atomic vectors can only contain objects of the same type, one might expect the following code, which tries to concatenate objects of different types, to produce an error:\n\nx &lt;- c(1, \"Hallo\")\n\nBut this is not what happens! R transforms the objects according to the hierarchy discussed above:\nlogical â†’ integer â†’ double â†’ character. Due to the absence of errors or warning messages, such operations are a regular source for mistakes.\nNote: The length of a vector corresponds to its numbers of elements. We can â€˜measureâ€™ its length using the function length():\n\nx =  c(1, 2, 3)\nlen_x &lt;- length(x)\nlen_x\n\n[1] 3\n\n\n\nTransgression: How large can an integer become? In R, objects of type integer are stored as 32-bit files. This means that for each single integer, 32 bits of storage are available on your computer. This implies that really large numbers cannot be stored as integers, simply because the 32 bits are not sufficient:\n\n\nx &lt;- 2147483647L\ntypeof(x)\n\n[1] \"integer\"\n\n\n\ny &lt;- 2147483648L\ntypeof(y)\n\n[1] \"double\"\n\n\n\nAs you can see, the largest number that we can store as 32-bit integer is 2147483647. Larger numbers must be stored as double. The drawback of saving numbers in this type is, however, the risk of a loss of precision. If you want to avoid this you could try to save an integer as a 64 bit integer. This possibility has been added to R later to save large numbers as integers (something that happens faster than you think). To do so we must use the package7 bit64:\n\n\nz &lt;- bit64::as.integer64(2147483648)\nbit64::is.integer64(z)\n\n[1] TRUE\n\n\n\nBecause this is a data type that has been added to R later, several functions do not work with 64-bit integers if the package bit64 is not installed. Moreover, several standard functions return very irritating outputs:\n\n\ntypeof(z)\n\n[1] \"double\"\n\n\n\nFor this reason, and because bit64 is not part of the standard installation of R, you should avoid storing large numbers as integer64 whenever possible. Very large numbers should be stored as double or, when precision is a serious issue, you should scale them down and then save them as integer.\n\n\n\nLogical operations\nThe logical values TRUE and FALSE are often the result of logical operations, such as â€˜Is 2 larger than 1?â€™. Such logical operations occur very frequently and its a good idea to familiarize yourself with the logical operators. You can find an overview in the following table:\n\n\n\nOperator\nFunction in R\nExample\n\n\n\n\nlarger\n&gt;\n2&gt;1\n\n\nsmaller\n&lt;\n2&lt;4\n\n\nequal\n==\n4==3\n\n\nlarger or equal\n&gt;=\n8&gt;=8\n\n\nsmaller or equal\n&lt;=\n5&lt;=9\n\n\nnot equal\n!=\n4!=5\n\n\nand\n&\nx&lt;90 & x&gt;55\n\n\nor\n|\nx&lt;90 | x&gt;55\n\n\neither or\nxor()\nxor(2&lt;1, 2&gt;1)\n\n\nnot\n!\n!(x==2)\n\n\nis true\nisTRUE()\nisTRUE(1&gt;2)\n\n\n\nThe result of such logical operations is always a logical value:\n\nx &lt;- 4\ny &lt;- x == 8\ntypeof(y)\n\n[1] \"logical\"\n\n\nYou may also test longer vectors:\n\nx &lt;- 1:3\nx&lt;2\n\n[1]  TRUE FALSE FALSE\n\n\nTests can also be chained:\n\nx &lt;- 1L\nx&gt;2 | x&lt;2 & (is.double(x) & x!=0)\n\n[1] FALSE\n\n\nSince many mathematical operations interpret TRUE as 1, it is easy to check how often a certain condition is met:\n\nx &lt;- 1:50 \nsmaller_20 &lt;- x&lt;20 \nprint(\n  sum(smaller_20) # How many elements are smaller then 20?\n  )\n\n[1] 19\n\nprint(\n  sum(smaller_20/length(x)) # Whats the share of these elements?\n)\n\n[1] 0.38\n\n\n\n\nVectorization\nThe chained operation we just saw is an example for vectorizing an operation. This means that the same operation is applied to many elements, all of which are concatenated as a vector. For instance, if you want to compute the square root of the numbers 5, 6 and 7 you could do:\n\nsqrt(5)\n\n[1] 2.236068\n\nsqrt(6)\n\n[1] 2.44949\n\nsqrt(7)\n\n[1] 2.645751\n\n\nOr you vectorize the operation:\n\nsqrt(c(5,6,7))\n\n[1] 2.236068 2.449490 2.645751\n\n\nVectorizing operations is very useful since it speeds up the computations considerably. Vectorized operations are far more efficient and faster than applying the operation to each element of the vector separately. Thus, whenever you need to apply a certain operation more than once you should always think about using vectorization.8\n\n\nMore on words\nWords are distinguished by the fact that their beginning and their end gets indicated by the symbol ' or \":\n\nx &lt;- \"Hello\"\ntypeof(x)\n\n[1] \"character\"\n\n\n\ny &lt;- 'Bye!'\ntypeof(y)\n\n[1] \"character\"\n\n\nJust as other kinds of atomic vectors, they can by concatenated using c():\n\nz &lt;- c(x, \"und\", y)\nz\n\n[1] \"Hello\" \"und\"   \"Bye!\" \n\n\nA useful function in this context is paste(), which transforms and combines elements of several vectors:\n\nx &lt;- 1:10\ny &lt;- paste(\"Try nb.\", x)\ny\n\n [1] \"Try nb. 1\"  \"Try nb. 2\"  \"Try nb. 3\"  \"Try nb. 4\"  \"Try nb. 5\" \n [6] \"Try nb. 6\"  \"Try nb. 7\"  \"Try nb. 8\"  \"Try nb. 9\"  \"Try nb. 10\"\n\n\nThe function paste() also accepts an optional argument sep, which allows us to specify a token that should be placed between the elements to be combined (the default is sep=\" \"):\n\nday_nr &lt;- 1:10\nx_axis &lt;- paste(\"Day\", day_nr, sep = \": \")\nx_axis\n\n [1] \"Day: 1\"  \"Day: 2\"  \"Day: 3\"  \"Day: 4\"  \"Day: 5\"  \"Day: 6\"  \"Day: 7\" \n [8] \"Day: 8\"  \"Day: 9\"  \"Day: 10\"\n\n\n\n*Note**: Here we have an example of what is called â€˜recyclingâ€™. since the vector c(\"Day\") was shorter than the vector day_nr, c(\"Day\") is simply copied so that the operation with paste() makes sense. Recycling is useful, but sometimes it can be harmful, namely when you think that you are using two vectors of the same length, but this is actually not the case. In such a case recycling leads to the fact that no error message is printed and the fact that the two vectors are not of the same length remains unnoticed An example of this is the following code, in which the intention is clearly to connect all weekdays to numbers and one weekday was simply forgotten:\n\n\ndays &lt;- paste(\"Tag \", 1:7, \":\", sep=\"\")\nday_names &lt;- c(\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\")\npaste(days, day_names)\n\n[1] \"Tag 1: Monday\"    \"Tag 2: Tuesday\"   \"Tag 3: Wednesday\" \"Tag 4: Thursday\" \n[5] \"Tag 5: Friday\"    \"Tag 6: Saturday\"  \"Tag 7: Monday\"   \n\n\n\n\nMissing values and NULL\nAs indicated above, missing values are encoded as NA. This is particularly useful in statistical contexts, where are particular element of a vector cannot simply be removed if it is unavailable.\n\nExample: The vector x contains a logical value that indicates whether a person has correctly answered the question on a questionnaire. If the person did not answer the third question on the questionnaire, this should be indicated by NA. Simply omitting the value makes it impossible to determine afterwards which question the person did not answer.\n\nMost operations that get NA as an input will also give NA as an output, because it is unclear what the result of the operation would be for different values for for the missing value:\n\n5 + NA\n\n[1] NA\n\n\nThe only exception is an operation that yields a certain value completely independent from what you would substitute for NA:\n\nNA | TRUE # Always TRUE, no matter what you substitute for NA\n\n[1] TRUE\n\n\nTo test whether a vector x contains missing values you should always use the function is.na, never x==NA:\n\nx &lt;- c(NA, 5, NA, 10)\nprint(x == NA) # Unclear since not clear whether all NA must stand for the same value\n\n[1] NA NA NA NA\n\nprint(\n  is.na(x)\n)\n\n[1]  TRUE FALSE  TRUE FALSE\n\n\nWhenever an operation yields a value that cannot be defined, the result is not NA but NaN (not a number):\n\n0 / 0\n\n[1] NaN\n\n\nAnother special element is NULL. NULL is in fact a data type in itself (i.e.Â it is not a vector), but in practice its best thought of as a vector of length zero:\n\nx &lt;- NULL\nlength(x)\n\n[1] 0\n\n\nNULL is frequently used to indicate that something does not exist. An empty vector, for instance, is NULL:\n\nx &lt;- c()\nx\n\nNULL\n\nlength(x)\n\n[1] 0\n\n\nThis is different to a vector with one (or more) missing elements:\n\ny &lt;- NA\nlength(y)\n\n[1] 1\n\n\nWhen you define your own functions, you might use NULL as the default value for optional arguments. We will learn about such more advanced strategies later in this course. For now, its best to think of NULL as an vector of length zero.\n\n\nIndexing and replacement\nWe can extract single elements of a vector using squared brackets:\n\nx &lt;- c(2,4,6)\nx[1]\n\n[1] 2\n\n\nThis also allows us to modify specific elements:\n\nx &lt;- c(2,4,6)\nx[2] &lt;- 99\nx\n\n[1]  2 99  6\n\n\nBut we can also extract more than one element:\n\nx[1:2]\n\n[1]  2 99\n\n\nNegative indices eliminate the respective elements:\n\nx[-1]\n\n[1] 99  6\n\n\nTo get the last element of a vector you might combine this idea with the function length():\n\nx[length(x)]\n\n[1] 6\n\n\n\n\nUseful functions when working with atomic vectors\nHere we shall mention a few functions that are particularly useful in the context of atomic vectors,9 especially when it comes to producing such vectors or to perform arithmetic operations with them.\nCreating atomic vectors:\nA sequence of whole numbers is something that we use very frequently. To create such sequences, the shortcut : comes in handy:\n\nx &lt;- 1:10\nx\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\n\ny &lt;- 10:1\ny\n\n [1] 10  9  8  7  6  5  4  3  2  1\n\n\nTo build more complex sequences we can use seq(), which in its simplest case is equivalent to ::\n\nx &lt;- seq(1, 10)\nprint(x)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nThe function seq(), however, allows for a number of useful optional arguments. For instance, by allows us to control the space between the numbers:\n\ny &lt;- seq(1, 10, by = 0.5)\nprint(y)\n\n [1]  1.0  1.5  2.0  2.5  3.0  3.5  4.0  4.5  5.0  5.5  6.0  6.5  7.0  7.5  8.0\n[16]  8.5  9.0  9.5 10.0\n\n\nIf we want to specify the desired length of the resulting vector and let R choose the necessary space between the elements, we may use length.out:\n\nz &lt;- seq(2, 8, length.out = 4)\nprint(z)\n\n[1] 2 4 6 8\n\n\nAnd if we want to create a vector with the length as another vector, the argument along.with comes in handy. This is often used for creating index vectors.10 In such a case we do not have to specify the index numbers directly:\n\nz_index &lt;- seq(along.with = z)\nprint(z_index)\n\n[1] 1 2 3 4\n\n\nAnother common task is to repeat a certain vector. This can be done with rep():\n\nx &lt;- rep(NA, 5)\nprint(x)\n\n[1] NA NA NA NA NA\n\n\nOperations\nThere are a number of operations that we use very frequently together with vectors. Often we are interested in the length of a vector. For this we can use the function length():\n\nx &lt;- c(1,2,3,4)\nlength(x)\n\n[1] 4\n\n\nIf we are looking for the largest and smallest value of a vector we can use min() and max():\n\nmin(x)\n\n[1] 1\n\n\n\nmax(x)\n\n[1] 4\n\n\nBoth functions (and many more similar functions) have the optional argument na.rm, which can be either TRUE or FALSE. In the case of TRUE, all NA values are removed before the operation gets applied:\n\ny &lt;- c(1,2,3,4,NA)\nmin(y)\n\n[1] NA\n\n\n\nmin(y, na.rm = TRUE)\n\n[1] 1\n\n\nThe mean or the variance/standard deviation of the elements can be computed with mean(), var(), and sd(), all of which have also the optional argumentna.rm:\n\nmean(x)\n\n[1] 2.5\n\n\n\nvar(y)\n\n[1] NA\n\n\n\nvar(y, na.rm = T)\n\n[1] 1.666667\n\n\nFinally, we often want to compute the sum or the product of all the elements of the vector. Here the functions sum() and prod() are useful:\n\nsum(x)\n\n[1] 10\n\n\n\nprod(y, na.rm = T)\n\n[1] 24"
  },
  {
    "objectID": "content/tutorials/obj-types-ii-vectors/index.html#lists",
    "href": "content/tutorials/obj-types-ii-vectors/index.html#lists",
    "title": "Fundamental object types in R II: Vectors",
    "section": "Lists",
    "text": "Lists\nIn contrast to atomic vectors, lists can contain objects of different types. We create lists via the function list():\n\nl_1 &lt;- list(\n  \"a\",\n  c(1,2,3),\n  FALSE\n)\ntypeof(l_1)\n\n[1] \"list\"\n\n\n\nl_1\n\n[[1]]\n[1] \"a\"\n\n[[2]]\n[1] 1 2 3\n\n[[3]]\n[1] FALSE\n\n\nLists can become very complex. The function str() (short for â€œstructureâ€) helps us to get a quick overview over a list and its elements:\n\nstr(l_1)\n\nList of 3\n $ : chr \"a\"\n $ : num [1:3] 1 2 3\n $ : logi FALSE\n\n\nWe can name the elements of lists:11\n\nl_2 &lt;- list(\n  \"first_element\" = \"a\",\n  \"second_element\" = c(1,2,3),\n  \"third_element\" = FALSE\n)\n\nWe can retrieve the names of all elements of the list with names():\n\nnames(l_2)\n\n[1] \"first_element\"  \"second_element\" \"third_element\" \n\n\nThere are two very important differences in the handling of vectors and lists:\n\nVectorization does not work for lists\nIndexing works differently\n\nThe first issue can be illustrated easily:\n\nvec_expl &lt;- c(1,2,3)\nlist_expl &lt;- list(1,2,3)\nsqrt(vec_expl)\n\n[1] 1.000000 1.414214 1.732051\n\n\nBut:\n\nsqrt(list_expl)\n\nError in sqrt(list_expl): non-numeric argument to mathematical function\n\n\nThe second issue is due to the more complex structure of lists. For vectors we extracted single elements via [. For lists, there is a difference between [ and [[. The former always returns a list:\n\nl_1[2]\n\n[[1]]\n[1] 1 2 3\n\n\nThe second then returns a vector and is more similar to the behavior of [ in the context of atomic vectors:\n\nl_1[[2]]\n\n[1] 1 2 3\n\n\nTo extract an element of this vector we can chain the brackets:\n\nl_1[[2]][3]\n\n[1] 3\n\n\nWe can also extract elements by their name:\n\nl_2[[1]]\n\n[1] \"a\"\n\n\n\nl_2[[\"first_element\"]]\n\n[1] \"a\"\n\n\nLists are fundamental to many more complex structures that we will encounter later. They are more flexible than atomic vectors, but this flexibility also makes them more difficult to use and less efficient for tasks where this flexibility is not needed. As a rule of thumb, whenever you can represent something as an atomic vector, you should do so. You should always have a good reason for using lists!"
  },
  {
    "objectID": "content/tutorials/obj-types-ii-vectors/index.html#footnotes",
    "href": "content/tutorials/obj-types-ii-vectors/index.html#footnotes",
    "title": "Fundamental object types in R II: Vectors",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nIn fact, we will learn below that 2 is not really a number, but a vector or length 1. Only in a next step, 2 counts as a â€˜numberâ€™, or, more precisely as a â€˜doubleâ€™.â†©ï¸\nThe only object type that is of relevance to us aside these two is NULL. We will learn about it during the end of this post.â†©ï¸\nWhile you can abbreviate the two with T and F, respectively, I recommend against using these sometimes ambiguous abbreviations.â†©ï¸\nThis syntax has historical reasons: when the type integer was introduced in R, the developers were guided by the type long integer of the programming language C. In C the suffix for such an integer was â€˜lâ€™ or â€˜Lâ€™. The R developers just transferred this practice into R, only they did not use â€˜iâ€™ to avoid a possible confusion between â€˜lâ€™ and â€˜iâ€™, which look very similar in many fonts (the suffix â€˜iâ€™ in R is used for the imaginary component of complex numbers).â†©ï¸\nIn principle there are different kinds of missing values, such as NA_integer_ or NA_character_, but they are irrelevant in practice: any NA value in an atomic vector automatically â€˜mimicsâ€™ the type of the atomic vector.â†©ï¸\nNULL on the other hand, is used to represent an absent vector, not an absent element of a vector. We will come back to NULL during the end of the post.â†©ï¸\nIf you are not sure what a package is, recap the last chapter of the post on first steps in R.â†©ï¸\nWe learn more about this later in the course when delving into the topic of iteration.â†©ï¸\nFor many common tasks there is already a predefined function in R. The easiest way to find them is by googlingâ†©ï¸\nAn index vector x to any vector y with N elements contains the integers from 1 to N. The nth value of x thus corresponds to the index of the nth value of y.â†©ï¸\nWe can actually also do this with vectors, but it is more common in the context of lists.â†©ï¸"
  },
  {
    "objectID": "content/tutorials/obj-types-iii-adv/index.html",
    "href": "content/tutorials/obj-types-iii-adv/index.html",
    "title": "Fundamental object types in R III: Factors and data frames",
    "section": "",
    "text": "In the previous posts you learned about the most important fundamental data types in R. The types we will learn about below and not less important, but less fundamental. This means they are built by taking one of the base types we encountered before, and â€˜adding some featuresâ€™. These features change the behavior of the type, e.g.m how it is printed or how it is affected by certain function calls, but also what kind of operations it allows.1\nThis process of â€˜adding featuresâ€™ is usually done by adding â€˜attributesâ€™ to an object. In principle, you can add attributes to any objects without much effect by using the attr() function:\n\nx &lt;- 2.0\nattr(x, \"Mood\") &lt;- \"Haha!\"\n\nTo retrieve attributes use attributes():\n\nattributes(x)\n\n$Mood\n[1] \"Haha!\"\n\n\nSometimes, adding attributes of a particular name have more relevant implications. One useful way to use attributes, for instance, is to name the single elements of vectors, something that changes the way the objects are printed and something that we already discussed in the context of lists:\n\ny &lt;- c(1, 2, 3)\nattr(y, \"names\") &lt;- c(\"First\", \"Second\", \"Third\")\ny\n\n First Second  Third \n     1      2      3 \n\n\n\nattributes(y)\n\n$names\n[1] \"First\"  \"Second\" \"Third\" \n\n\nNow we can call elements by their name:\n\ny[\"Second\"]\n\nSecond \n     2 \n\n\nBut things become really interesting if you add an attribute called class: this really transforms the data types into a new, less fundamental type. In fact, this is how the types we discuss below, are created: smart people added, among other things, a class attribute to a more fundamental data type (integer in the case of factors and list in the case of data.frames). The art of writing new classes is part of object oriented programming, an advanced concept that we do not cover in this course (and, to be honest, one of the areas where R is not particularly well designed).\nOne implication of this â€˜less fundamentalâ€™ nature of the objects we encounter below is that typeof() usually returns the base type. For instance, below we will learn about the factor, a type that is built upon integer. If we call typeof() on a factor, it will return the fundamental type, i.e.Â integer:\n\nxx &lt;- factor(c(1,2))\ntypeof(xx)\n\n[1] \"integer\"\n\n\nFortunately, the standard test functions (is.*()) usually work, so you can use is.factor():\n\nis.factor(xx)\n\n[1] TRUE\n\n\nAlternatively, you can always inspect that attributes of the object to find out about its class:\n\nattributes(xx)\n\n$levels\n[1] \"1\" \"2\"\n\n$class\n[1] \"factor\"\n\n\nAll this can be confusing at first, so it is important to keep it in mind. Once you wrapped your head upon this, many confusing behaviors suddenly start to make sense, e.g.Â that mutating factors within a data.frame can result in whole numbers, a phenomenon we will discuss in the context of data wrangling later."
  },
  {
    "objectID": "content/tutorials/obj-types-iii-adv/index.html#footnotes",
    "href": "content/tutorials/obj-types-iii-adv/index.html#footnotes",
    "title": "Fundamental object types in R III: Factors and data frames",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nIn fact, some new types allow you to do less than the original type, i.e.Â here the new features are restrictions. The tibble we will encounter below is such an example.â†©ï¸\nIf you read the section on attributes above: matrices are objects that were given a new attribute dim.â†©ï¸\nThis is another piece of evidence for the very confusing class concept and object-orientated style of R. See this chapter for more details, in case you are interested.â†©ï¸"
  },
  {
    "objectID": "content/tutorials/setting-up-an-r-project/index.html",
    "href": "content/tutorials/setting-up-an-r-project/index.html",
    "title": "Setting up an R project",
    "section": "",
    "text": "This post is about how you set up an adequate project environment. By this I mean the folders you should create, and how you should save your files. The structure introduced here will help you to keep your project structured and to keep an overview about your work, but also to make it easier to share your project with others.\nIn all, whenever you start a new programming project you should set up the infrastructure described below. Such project could be a term paper, a research endeavor, or just the code to create some visualizations. Later you might find that some aspects of the infrastructure below feel like a bit of an overkill, especially for very small undertakings. But especially in the beginning its better to be save than sorry and to set up the whole project as described below.\nIn all, setting up a good working environment includes the following steps:\n\nFind a good place for the project on your computer.\nCreate a directory with an R project\nCreate the relevant sub-directories\n\nThen you should always familiarize yourself with how to use the here-package with your project.\nThere are some additional steps one might to take, such as initiating a Git repository or setting up a renv environment . Moreover, for larger projects you might also want to add a README.md. But for now the steps mentioned above are sufficient. But before going through them one by one, we need to clarify two important technical concepts:\n\nthe concept of a working directory and\nthe distinction between absolute and relative paths"
  },
  {
    "objectID": "content/tutorials/setting-up-an-r-project/index.html#footnotes",
    "href": "content/tutorials/setting-up-an-r-project/index.html#footnotes",
    "title": "Setting up an R project",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nWe could also have created a folder in the previous step and then chosen this folder here via Existing directory. This is useful if you want to add an R project file to an already existing project, but the approach of creating a new directory is more general and should be your default approach.â†©ï¸\nWith R Markdown you can write texts directly in R. This allows you to keep statistical analysis and the description of the results in one document. This homepage, for example, was also written entirely in R Markdown. You will learn how to use R-Markdown soon.â†©ï¸"
  },
  {
    "objectID": "content/tutorials/using-exercises/index.html",
    "href": "content/tutorials/using-exercises/index.html",
    "title": "Using the exercise package",
    "section": "",
    "text": "When learning a programming language, applying the new concepts regularly is absolutely essential. Without regular practice it is hard to impossible to remember everything you need to actually enjoy working with R.\nTherefore, I prepared a small set of exercises for each session that I recommend you to do after the session. This will help you to remember what you have learned and to find out what you did not understand well. I then urge you to post your problems on Moodle, to ask your colleagues and to help each other out. This will be a great boost to your learning progress: explaining something to others is not only great in a normative sense, it also helps you to get a deeper understanding of the concepts yourself.\nIn this short post I quickly explain how you can use the exercises that I have prepared for you. For those of you interested in the underlying mechanics: all exercises were prepared using the package learnr together with the gradethis package, and are distributed in the package DataScienceExercises.\nTo use the exercises you must have installed the packages learnr, gradethis and DataScienceExercises. If you followed the instructions in the tutorial on installing R packages this should be the case. If for some reasons you need to install them, you can do this via:\n\npack_names &lt;- c(\n  \"rstudio/learnr\",\n  \"rstudio/gradethis\",\n  \"graebnerc/DataScienceExercises\"\n)\nremotes::install_github(\n  repo = pack_names, upgrade = \"always\")\n\nNote that this requires a previous installation of the package remotes:\n\ninstall.packages(\"remotes\")\n\nSince I update the exercises according to your feedback, and add new exercises over the semester, I strongly recommend you to update the package DataScienceExercises each time before you start practicing. To do so you need an internet connection. If you just want to do the exercises without updating the package, an internet connection is not required: the exercises themselves also work offline.\nTo update the package, simply type the following into the console and press Enter:\n\nremotes::install_github(\n  repo = \"graebnerc/DataScienceExercises\", upgrade = \"always\")\n\nThis should update your package version to the most recent release.\nIf you want to start an exercise you first need to figure out the name of the exercise sheet. This is provided in the Material section of the course webpage. Then you call execute the following code via the console in R Studio, replacing â€˜EX_NAMEâ€™ with the name of the exercise sheet:\n\nlearnr::run_tutorial(\n  name = \"EX_NAME\", \n  package = \"DataScienceExercises\", \n  shiny_args=list(\"launch.browser\"=TRUE))\n\nThe first exercise sheet, for instance, is called Basics. Thus, to call it execute the following:\n\nlearnr::run_tutorial(\n  name = \"Basics\", \n  package = \"DataScienceExercises\", \n  shiny_args=list(\"launch.browser\"=TRUE))\n\nLastly, if you encounter a bug or a mistake, or have an idea for a good exercise, please let me know via the issue tracker of the DataScienceExercises package or via Moodle. Thank you!"
  },
  {
    "objectID": "content/tutorials/visualization/index.html",
    "href": "content/tutorials/visualization/index.html",
    "title": "Visualization",
    "section": "",
    "text": "Packages used\n\nlibrary(DataScienceExercises)\nlibrary(ggplot2)\n\n\n\nDeveloping a ggplot - the general workflow\nMake a shortcut to the data and inspect it:\n\ngdp_data &lt;- DataScienceExercises::gdplifexp2007\nhead(gdp_data, 3)\n\n        country continent lifeExp        pop gdpPercap\n1         China      Asia  72.961 1318683096  4959.115\n2         India      Asia  64.698 1110396331  2452.210\n3 United States  Americas  78.242  301139947 42951.653\n\n\nPlots in ggplot2 are created layer by layer. We now go through each step that, in the end, will produce the following plot:\n\n\n\n\n\nWe start by creating the basic ggplot2 object, which is best thought of as a fancy list. To this end we use the function ggplot2::ggplot()\n\ngdp_plot &lt;- ggplot2::ggplot()\ntypeof(gdp_plot)\n\n[1] \"list\"\n\n\nWhen we call this list, the plot described by it gets rendered:\n\ngdp_plot\n\n\n\n\nOf, course, there is no plot since the list is basically empty. All the specifications in the ggplot2::ggplot() function are best thought of as default values. In our case we fist specify the data set we use for our plot:\n\ngdp_plot &lt;- ggplot2::ggplot(\n  data = gdp_data\n)\n\nBut this alone does not do anything good. We also need to inform ggplot2 on how it should map the variables from the data set onto the plot. In a first step, lets clarify that the variable gdpPercap should be mapped on the x-axis and the variable lifeExp on the y-axis.\nThis is done via the argument mapping and the function ggplot2::aes(), which takes as arguments the aesthetics of the plot and the variable names that should be plotted on them:\n\ngdp_plot &lt;- ggplot2::ggplot(\n  data = gdp_data, \n  mapping = ggplot2::aes(\n    x = gdpPercap,\n    y = lifeExp\n  )\n)\ngdp_plot\n\n\n\n\nThis looks better. Note that ggplot2 chooses a default range for the axes based on the range of the variables in the underlying data set:\n\nmin(gdp_data$lifeExp); max(gdp_data$lifeExp)\n\n[1] 39.613\n\n\n[1] 82.603\n\nmin(gdp_data$gdpPercap); max(gdp_data$gdpPercap)\n\n[1] 277.5519\n\n\n[1] 49357.19\n\n\nWe now want to add an additional layer with data points on our plot. Poits are so called geom: a certain geometrical object representing data points. The function to add points is called ggplot2::geom_point() amd we literally just add it to our plot:\n\ngdp_plot &lt;- gdp_plot + geom_point()\ngdp_plot\n\n\n\n\nThis already reveals much of the general workflow involved in creating a plot: define a raw object and add and refine layers. Looking at the plot above, one thing that is missing is that the dots are filled in different colors, representing the continents of the countries, and the size of the dots represent the population size of the countries.\nTo achieve this we need to map the variable continent from the data set to the aesthetic color in the plot, and the variable pop to the aesthetic size:\n\ngdp_plot &lt;- ggplot2::ggplot(\n  data = gdp_data, \n  mapping = ggplot2::aes(\n    x = gdpPercap,\n    y = lifeExp,\n    size = pop, \n    color = continent\n    )\n  ) +\n  ggplot2::geom_point()\ngdp_plot\n\n\n\n\nWhat is not so nice is that the points are partly overlapping and bigger points might conceal smaller points below them. To address this problem we might make the plots a bit transparent. Since this is not a mapping from a variable from the data set to an aesthetic, but a general setting that should apply to all points equally, we do not specify it via the argument aes, but via the parameter responsible for transparency directly. This parameter is called alpha and we can set it for the affected geom directly:\n\ngdp_plot &lt;- ggplot2::ggplot(\n  data = gdp_data, \n  mapping = ggplot2::aes(\n    x = gdpPercap,\n    y = lifeExp,\n    size = pop, \n    color = continent\n    )\n  ) +\n  ggplot2::geom_point(alpha=0.5)\ngdp_plot\n\n\n\n\nBut now there is the danger for points to â€˜melt into each otherâ€™. Better have their circle in black, and only color their interior. We can do so by replacing color in the aesthetics with fill, and set the color explicitly to 'black'. However, this distinction between circle color and fill color is not available for all kind of point shapes. You need to search the internet for a shape that supports this distinction. If you looked, for instance, here you found that they shape with index 21 allows this:\n\ngdp_plot &lt;- ggplot2::ggplot(\n  data = gdp_data, \n  mapping = ggplot2::aes(\n    x = gdpPercap,\n    y = lifeExp,\n    size = pop, \n    fill = continent\n    )\n  ) +\n  ggplot2::geom_point(\n    shape=21, color=\"black\", alpha=0.5)\ngdp_plot\n\n\n\n\nProgress cannot be denied! Now lets fix the labels and annotations of the plot. Here, the function ggplot2::labs() comes in handy. It accepts arguments such as title, subtitle, captio, and several more. The help() function gives further information about the possibilities.\nIn our case we want to add a title, specify the x and y axis, and add a caption:\n\ngdp_plot &lt;- gdp_plot +\n  ggplot2::labs(\n    title = \"Life expectancy and income per capita\", \n    caption = \"Note: size of bubbles represents population. Data: Gapminder\",\n    x = \"GDP per capita (int. Dollar)\",\n    y = \"Life expectancy in years\"\n  )\ngdp_plot\n\n\n\n\nSo far, so good. The x-axis is a bit clumsy, though. It would be better to scale the number down so that it shows 1000 dollars. The scale properties of the axes can be defined by the functions scale_*_**(), where the first * should be replaced by the aesthetic we want to adjust, and the second by a keyword indicating whether the variable is discrete or continuous, or whether we want to provide fully manual specifications. In our case we are interested in changing the x-axis, which represents a continuous variable (GDP). Thus we call scale_x_continuous(). Since we want to change the labels on the axis we specify the argument labels. To scale the labels we make use of a function from the scales-package: scales::number_format(). And to make this clear on the axis we add the suffix â€˜kâ€™:\n\ngdp_plot &lt;- gdp_plot +\n  ggplot2::scale_x_continuous(\n    labels = scales::number_format(scale = 0.001, suffix = \"k\")\n    )\ngdp_plot\n\n\n\n\nNow lets turn to the legends. First of all we want to remove the legend for the bubble size since, first, the mapping of the bubble size is not straightforward to understand and, second, we already indicated that the bubble size represents population in the caption of the plot. There are several ways to to this: either we use the scale_*_*() function we already encountered with the argument guide=\"none\":\n\ngdp_plot + ggplot2::scale_size_continuous(guide = \"none\")\n\nOr we use a function that allows us to specify all kinds of legend properties: ggplot2::guides(). Here we take the aesthetic name as an argument and set it to Â´â€œnoneâ€`:\n\ngdp_plot &lt;- gdp_plot + ggplot2::guides(size = \"none\")\ngdp_plot\n\n\n\n\nThe advantage of using ggplot2::scale_size_continuous() would be that we could strech the limits a bit to make the differences more straightforward to see:\n\ngdp_plot &lt;- gdp_plot + \n  ggplot2::scale_size_continuous(\n    guide = \"none\", \n    range = c(0.1, 24)\n    )\n\nNow we want to put the remaining legend to the bottom of the plot. Again, there are several ways to achieve this, but for such specific changes the function ggplot2::theme() is usually a good option. It allows us to change almost everything on a plot. The argument to place legends at the bottom is legend.position and already hints at the internal logic of theme(), which you might explore through the help() function yourself:\n\ngdp_plot &lt;- gdp_plot +\n  ggplot2::theme(legend.position = \"bottom\")\ngdp_plot\n\n\n\n\nSince the theme() function is so extensive there are also many pre-defined themes for plots, which are best explored in the internet. A good default one is the black-and-white theme, which we can use via ggplot2::theme_bw():\n\ngdp_plot &lt;- gdp_plot +\n  ggplot2::theme_bw()\ngdp_plot\n\n\n\n\nOups, while everything looks nicer, some of our previous changes, such as moving the legend to the bottom and removing its title were overwritten! It, thus, makes always sense to first call the default theme, and then make further changes via ggplot::theme().\nOf course, we can then also make further adjustments to the theme, e.g.Â  by removing the panel of the plot. Removing elements of the plot via ggplot2::theme() requires us to set these elements via the function ggplot2::element_blank():\n\ngdp_plot &lt;- gdp_plot +\n  ggplot2::theme_bw() +\n  theme(\n    legend.position = \"bottom\",\n    panel.border = ggplot2::element_blank()\n  )\ngdp_plot\n\n\n\n\nHm, but it would indeed be a bit nicer to keep the axis lines of the x- and y-axis. Lets do this by specifying them explicitly via ggplot2::element_line(), which again allows for endless specification details:\n\ngdp_plot &lt;- gdp_plot +\n  ggplot2::theme(\n    axis.line = ggplot2::element_line(colour = \"grey\"))\ngdp_plot\n\n\n\n\nIts time to get picky! The ticks of the values should have the same color as the axis lines!!!\n\ngdp_plot &lt;- gdp_plot +\n  ggplot2::theme(\n    axis.ticks = ggplot2::element_line(colour = \"grey\"))\ngdp_plot\n\n\n\n\nOkay, you should get the general idea. What is more worrisome, to be honest, is the ugly title of the legend. Away with it!\n\ngdp_plot &lt;- gdp_plot +\n  ggplot2::theme(legend.title = ggplot2::element_blank())\ngdp_plot\n\n\n\n\nSo, the only thing that distinguishes our plot from the initial example is the color pallette. There are many different pallettes available, you can search for your favorite one in the internet. Here we use one provided by the package RColorBrewer, which can be used for the fill-aesthetic direclty:\n\ngdp_plot &lt;- gdp_plot +\n  ggplot2::scale_fill_brewer(palette = \"Dark2\")\ngdp_plot\n\n\n\n\nThats it! This was, of course, only a tiny glimpse on what you can achieve using ggplot2, but it should suffice for the start. Moreover, what is more important, you learned about the general workflow when developing a plot: start with creating a list with Â´ggplot2::ggplot()` and then adjust your plot layer by layer until you are satisfied.\nHere is the whole code we used for the figure:\n\ngdp_plot &lt;- ggplot2::ggplot(\n  data = gdp_data, \n  mapping = ggplot2::aes(\n    x = gdpPercap,\n    y = lifeExp,\n    size = pop, \n    fill = continent\n  )\n) +\n  ggplot2::geom_point(\n    shape=21, color=\"black\", alpha=0.5) +\n  ggplot2::labs(\n    title = \"Life expectancy and income per capita\", \n    caption = \"Note: size of bubbles represents population. Data: Gapminder\",\n    x = \"GDP per capita (int. Dollar)\",\n    y = \"Life expectancy in years\"\n  ) +\n  ggplot2::scale_x_continuous(\n    labels = scales::number_format(scale = 0.001, suffix = \"k\")\n  ) + \n  ggplot2::scale_size_continuous(\n    guide = \"none\", \n    range = c(0.1, 24)\n  ) +\n  ggplot2::scale_fill_brewer(\n    palette = \"Dark2\"\n    ) +\n  ggplot2::theme_bw() +\n  ggplot2::theme(\n    legend.position = \"bottom\",\n    legend.title = ggplot2::element_blank(),\n    panel.border = ggplot2::element_blank(),\n    axis.line = ggplot2::element_line(colour = \"grey\"),\n    axis.ticks = ggplot2::element_line(colour = \"grey\")\n  )\n\nOf course, for simple exploratory analysis, you do not need so many details as we just did, but for publication purposes its good to know how far you can get!\nAnother great thing is that the syntax remains largely the same, no matter whether you want to make a scatter plot as above, or a line graph or a histogram. All that changes is the particular geom_*() function used.\n\n\nAn alternativ line plot\nTo illustrate the similarities of the code used for a different plot type, we will now use a data set that is very similar to the one used previously, only this time we have observations for GDP per capita and life expectancy for several years, aggregated for the different continents. The data set is gain made available via the package DataScienceExercises:\n\ngdp_data_agg &lt;- DataScienceExercises::aggGDPlifexp\n\nAgain, we first inspect the data to get a feeling about the variables that are present:\n\nhead(gdp_data_agg, 3)\n\n# A tibble: 3 Ã— 5\n  continent  year lifeExp      pop gdpPercap\n  &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n1 Africa     1952    39.1 4570010.     1253.\n2 Africa     1957    41.3 5093033.     1385.\n3 Africa     1962    43.3 5702247.     1598.\n\n\nLets plot the dynamics of GDP per capita over time for the different continents. We can now simply copy-paste a lot of the code we have used before. Lets start with the uncontroversial beginning and just replace the name of the data set and the variable names:\n\ngdp_dyn_plot &lt;- ggplot2::ggplot(\n  data = gdp_data_agg, # &lt;- Replaced \n  mapping = ggplot2::aes(\n    x = year, # &lt;- Replaced \n    y = gdpPercap, # &lt;- Replaced \n    color = continent#, \n    #fill = continent # &lt;- Not necessary \n  )\n) +\n  ggplot2::geom_point() \ngdp_dyn_plot\n\n\n\n\nThis is not so bad! But it would be nice to add an additional geom that connects the dots with lines. No problem, simply add ggplot2::geom_line() to the plot:\n\ngdp_dyn_plot &lt;- gdp_dyn_plot +\n  geom_line()\ngdp_dyn_plot\n\n\n\n\nMuch of the code above only requires slight adjustments: the scaling of the x-axis should now be applied to the y-axis so we change ggplot2::scale_x_continuous() into ggplot2::scale_y_continuous(). Moreover, colors should change not for the fill but the color aesthetic, so ggplot2::scale_fill_brewer() becomes ggplot2::scale_color_brewer():\n\ngdp_dyn_plot &lt;- gdp_dyn_plot +\n  ggplot2::scale_y_continuous(\n    labels = scales::number_format(scale = 0.001, suffix = \"k\")\n  ) + \n  ggplot2::scale_color_brewer(\n    palette = \"Dark2\"\n    )\ngdp_dyn_plot\n\n\n\n\nAside from this, we can pretty much re-use almost the entire code from above with which we adjusted the legend, the labels, as well as the overall theme, only we can be so bold to remove the title of the x-axis via axis.title.x = ggplot2::element_blank(). Moreover, since we do not map the population size, ggplot2::scale_size_continuous() can now be removed, resulting in:\n\ngdp_dyn_plot &lt;- gdp_dyn_plot +\n  labs(\n    title = \"The divergence of income per capita\", \n    caption = \"Note: country data averaged over continants. Data: Gapminder\",\n    y = \"GDP per capita (int. Dollar)\"\n  ) +\n  ggplot2::theme_bw() +\n  theme(\n    legend.position = \"bottom\",\n    legend.title = ggplot2::element_blank(),\n    panel.border = ggplot2::element_blank(),\n    axis.line = ggplot2::element_line(colour = \"grey\"),\n    axis.ticks = ggplot2::element_line(colour = \"grey\"),\n    axis.title.x = ggplot2::element_blank()\n  )\ngdp_dyn_plot\n\n\n\n\nAgain, a very nice plot - and much faster to complete than the first one, thanks to the amazingly consistent syntax of ggplot2:)\n\n\nSaving your plot\nYou can save your plot using the function ggplot2::ggsave(). The function saves, by default, the last plot you created, but it is better to specify the plot you want to save directly. Other important arguments are the file name (which also determines the format), and the size:\n\nggplot2::ggsave(\n  plot = gdp_plot, \n  filename = \"gdp_plot.pdf\", \n  width = 6, height = 4.2)"
  },
  {
    "objectID": "content/exercises/multiple-regression/index.html",
    "href": "content/exercises/multiple-regression/index.html",
    "title": "Exercises on multiple linear regression",
    "section": "",
    "text": "Read in the data set coffee_data.csv.\nIt contains the following variables:\n\nCoffeePrice: The world market price for coffee from Brazil in EUR per kilo\nCoffeeDemand: The demand for coffee from Brazil in tons\nCoffeeSeller: The kind of coffee company: Standard or FairTrade\n\nIn the following, treat CoffeeDemand as the dependent variable, and CoffeePrice and CoffeeSeller as the independent variables.\nEstimate a parallel slopes model, and an interaction model. Which of the models would you prefer?\nYou should justify your choice using two main arguments.\n\n\n\nRead in the data set ice_data.csv. What kind of relationships could you reasonably study in a linear regression framework (without further data transformation).\n\n\n\nThe solutions to both exercises can be found here."
  },
  {
    "objectID": "content/exercises/multiple-regression/index.html#studying-coffee-data",
    "href": "content/exercises/multiple-regression/index.html#studying-coffee-data",
    "title": "Exercises on multiple linear regression",
    "section": "",
    "text": "Read in the data set coffee_data.csv.\nIt contains the following variables:\n\nCoffeePrice: The world market price for coffee from Brazil in EUR per kilo\nCoffeeDemand: The demand for coffee from Brazil in tons\nCoffeeSeller: The kind of coffee company: Standard or FairTrade\n\nIn the following, treat CoffeeDemand as the dependent variable, and CoffeePrice and CoffeeSeller as the independent variables.\nEstimate a parallel slopes model, and an interaction model. Which of the models would you prefer?\nYou should justify your choice using two main arguments."
  },
  {
    "objectID": "content/exercises/multiple-regression/index.html#exploring-feasible-model-specifications",
    "href": "content/exercises/multiple-regression/index.html#exploring-feasible-model-specifications",
    "title": "Exercises on multiple linear regression",
    "section": "",
    "text": "Read in the data set ice_data.csv. What kind of relationships could you reasonably study in a linear regression framework (without further data transformation)."
  },
  {
    "objectID": "content/exercises/multiple-regression/index.html#solutions",
    "href": "content/exercises/multiple-regression/index.html#solutions",
    "title": "Exercises on multiple linear regression",
    "section": "",
    "text": "The solutions to both exercises can be found here."
  },
  {
    "objectID": "content/exercises/obj-types-exercises/index.html",
    "href": "content/exercises/obj-types-exercises/index.html",
    "title": "Basic object types: exercises",
    "section": "",
    "text": "Task 1\nCreate a vector containing the numbers 2, 5, 2.4 and 11.\n\nWhat is the type of this vector?\nReplace the second element with 5.9.\nAdd the elements 3 and 1 to the beginning, and the elements \"8.0\" and \"9.2\" to the end of the vector.\nTransform this vector into the type integer. What happens?\n\n\n\nTask 2\n\nWhat type is the following vector: \"2\", \"Hello\", 4.0, and TRUE\nWhat hierarchy is underlying this?\n\n\n\nTask 3\n\nCreate a vector with the numbers from -8 to 9 (step size: 0.5)\nCompute the square root of each element of the first vector using vectorisation. Anything that draws your attention?\n\n\n\nTask 4\nCreate a list that has three named elements: \"A\", \"B\", and \"C\"\n\nThe element \"A\" should contain the square root of the numbers form -2 to 8 (step size: 1)\nThe element \"B\" should contain the log of numbers between 2 and 4 (step size: 0.5)\nThe element \"C\" should contain letters from a1 to g7 (hint: use the pre-defined vector letters and the function paste())\n\nLink to the solutions"
  },
  {
    "objectID": "content/exercises/quarto-exercises/index.html",
    "href": "content/exercises/quarto-exercises/index.html",
    "title": "Quarto exercises",
    "section": "",
    "text": "Create a new Quarto document where you set the title, date, and the author explicitly. Write a sample text that comprisesâ€¦\n\nâ€¦at least one level 1 heading\nâ€¦at least two level 2 headings\nâ€¦a YAML part that specifies that R code remains hidden by default\nâ€¦one R chunk where both the output and the code is printed in the final document\nâ€¦one R chunk that produces a simply ggplot object and where the code producing the plot is hidden\n\nThen do the following:\n\nKnit the document to html with a floating table of contents and a special theme.\nMake the document available via Netlify Drop and add the possibility to download the underlying Rmd file. Note: For Netlify Drop to work, the html file must be called index.html!\nKnit the document to PDF and make sure that it includes a table of contents.\n\nA sample solution for the Rmd file can be found here (the Netlify version is here)."
  },
  {
    "objectID": "content/material/session05.html#lecture-script",
    "href": "content/material/session05.html#lecture-script",
    "title": "ğŸ—“ï¸ Session 5: Recap and practice",
    "section": "ğŸ‘¨â€ğŸ« Lecture script",
    "text": "ğŸ‘¨â€ğŸ« Lecture script\n\nThe script summarizing the key parts of the session"
  },
  {
    "objectID": "content/material/session05-notes.html",
    "href": "content/material/session05-notes.html",
    "title": "First recap session",
    "section": "",
    "text": "library(DataScienceExercises)"
  },
  {
    "objectID": "content/material/session05-notes.html#using-functions",
    "href": "content/material/session05-notes.html#using-functions",
    "title": "First recap session",
    "section": "Using functions",
    "text": "Using functions\nFunctions are algorithms that apply a certain routine on an input, thereby producing (almost always) an output. The function sqrt(), for instance, takes as input a number and returns as output another number, namely the square root of the input:\n\nsqrt(2.5)\n\n[1] 1.581139\n\n\nTo call a function we first write its name, followed by parentheses. Inside the parentheses we can specify the arguments of the function. Most of the time, the first argument(s) are the input(s).\nOften, you can give more arguments to the function. These specify how the algorithm of the function works. If you are not sure which arguments a function accepts, you can always use help().\nLet us consider the example of mean(). This function takes a vector of numbers as input and returns the mean of these numbers:\n\ntest_1 &lt;- c(1, 4, 2, 4, 9, NA, 44)\nmean(test_1)\n\n[1] NA\n\n\nThis result might be surprising. Lets inspect mean() further:\n\nhelp(mean)\n\nWe see that the first argument of mean() is called x. We can, but do not have to specify this name for the first argument. Neither we must for the further argumens, but this is highly recommended.\nThere are two more arguments for mean(): trim and na.rm. In our case, the second one is relevant: if na.rm is set to TRUE, the function removes all NA values from the input before computing the mean:\n\nmean(test_1, na.rm = TRUE)\n\n[1] 10.66667"
  },
  {
    "objectID": "content/material/session05-notes.html#defining-functions",
    "href": "content/material/session05-notes.html#defining-functions",
    "title": "First recap session",
    "section": "Defining functions",
    "text": "Defining functions\nWhenever you perform certain actions several times, it is often a good idea to define a function. This way, you can call the function instead of writing the code for the action every time anew.\nAssume we want to define a function that takes as input a vector of numbers and returns the sum of the natural logarithms of these numbers.\nWe define a new function by using the function function(). - We start our definition by associating the new function with a name (here: log_sum) so that we can use it later. - The arguments to function() are then arguments that our new function should accept. In our case, we only have one argument. - After that comes the function body. It contains all the routines that the function should execute when called. The function body is always enclosed by curly brackets. - Finally, we use the return() function to specify what the function should return. This is not strictly necessary, but it is a good practice to do so.\n\nlog_sum &lt;- function(input_vector){\n  logs &lt;- log(input_vector)\n  sum_logs &lt;- sum(logs)\n  return(sum_logs)\n}\n\nWe can then call the function by name:\n\nlog_sum(c(1, 2, 3, 4, 5))\n\n[1] 4.787492"
  }
]